{"version":3,"sources":["../src/index.js"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["import generate from \"babel-generator\";\n\ntype Node = {\n  type: string;\n};\n\ntype Literal = {\n  type: 'StringLiteral' | 'BooleanLiteral' | 'NumericLiteral' | 'NullLiteral' | 'RegExpLiteral'\n};\n\ntype Identifier = {\n  type: string;\n  name: string;\n};\n\ntype QualifiedTypeIdentifier = {\n  id: Identifier;\n  qualification: Identifier|QualifiedTypeIdentifier;\n};\n\ntype TypeAnnotation = {\n  type: string;\n};\n\ntype VisitorContext = {\n  inspect: Identifier;\n};\n\ninterface StringLiteralTypeAnnotation extends TypeAnnotation {\n  type: 'StringLiteralTypeAnnotation';\n}\n\ninterface NumericLiteralTypeAnnotation extends TypeAnnotation {\n  type: 'NumericLiteralTypeAnnotation';\n}\n\ninterface BooleanLiteralTypeAnnotation extends TypeAnnotation {\n  type: 'BooleanLiteralTypeAnnotation';\n}\n\ntype Scope = {};\n\ntype NodePath = {\n  type: string;\n  node: Node;\n  scope: Scope;\n};\n\n/**\n * # Typecheck Transformer\n */\nexport default function ({types: t, template}): Object {\n  /**\n   * Binary Operators that can only produce boolean results.\n   */\n  const BOOLEAN_BINARY_OPERATORS: string[] = [\n    '==',\n    '===',\n    '>=',\n    '<=',\n    '>',\n    '<',\n    'instanceof'\n  ];\n\n  const checks: Object = createChecks();\n  const staticChecks: Object = createStaticChecks();\n\n  const checkIsArray: (() => Node) = expression(`Array.isArray(input)`);\n  const checkIsMap: (() => Node) = expression(`input instanceof Map`);\n  const checkIsSet: (() => Node) = expression(`input instanceof Set`);\n  const checkIsClass: (() => Node) = expression(`typeof input === 'function' && input.prototype && input.prototype.constructor === input`);\n  const checkIsGenerator: (() => Node) = expression(`typeof input === 'function' && input.generator`);\n  const checkIsIterable: (() => Node) = expression(`input && (typeof input[Symbol.iterator] === 'function' || Array.isArray(input))`);\n  const checkIsObject: (() => Node) = expression(`input != null && typeof input === 'object'`);\n  const checkNotNull: (() => Node) = expression(`input != null`);\n  const checkEquals: (() => Node) = expression(`input === expected`);\n\n  const declareTypeChecker: (() => Node) = template(`\n    const id = (function () {\n      function id (input) {\n        return check;\n      };\n      Object.defineProperty(id, Symbol.hasInstance, {\n        value: function (input) {\n          return id(input);\n        }\n      });\n      return id;\n    })();\n  `);\n\n  const guard: (() => Node) = template(`\n    if (!check) {\n      throw new TypeError(message);\n    }\n  `);\n\n  const thrower: (() => Node) = template(`\n    if (check) {\n      ret;\n    }\n    else {\n      throw new TypeError(message);\n    }\n  `);\n\n  const guardInline: (() => Node) = expression(`\n    (id => {\n      if (!check) {\n        throw new TypeError(message);\n      }\n      return id;\n    })(input)\n  `);\n\n  const guardFn: (() => Node) = expression(`\n    function name (id) {\n      if (!check) {\n        throw new TypeError(message);\n      }\n      return id;\n    }\n  `);\n\n  const readableName: (() => Node) = expression(`\n    inspect(input)\n  `);\n  const checkMapKeys: (() => Node) = expression(`\n    input instanceof Map && Array.from(input.keys()).every(key => keyCheck)\n  `);\n\n  const checkMapValues: (() => Node) = expression(`\n    input instanceof Map && Array.from(input.values()).every(value => valueCheck)\n  `);\n\n  const checkMapEntries: (() => Node) = expression(`\n    input instanceof Map && Array.from(input).every(([key, value]) => keyCheck && valueCheck)\n  `);\n\n  const checkSetEntries: (() => Node) = expression(`\n    input instanceof Set && Array.from(input).every(value => valueCheck)\n  `);\n\n  const checkObjectIndexers: (() => Node) = expression(`\n    Object.keys(input).every(key => {\n      const value = input[key];\n      if (~fixedKeys.indexOf(key)) {\n        return true;\n      }\n      else {\n        return check;\n      }\n    });\n  `);\n\n  const checkObjectIndexersNoFixed: (() => Node) = expression(`\n    Object.keys(input).every(key => {\n      const value = input[key];\n      return check;\n    });\n  `);\n\n  const propType: (() => Node) = expression(`\n    (function(props, name, component) {\n      var prop = props[name];\n      if(!check) {\n        return new Error(\n          \"Invalid prop \\`\" + name + \"\\` supplied to \\`\" + component\n          + \"\\`.\\\\n\\\\nExpected:\\\\n\" + expected + \"\\\\n\\\\nGot:\\\\n\" + got + \"\\\\n\\\\n\"\n        );\n      }\n    })\n  `);\n\n  const PRAGMA_IGNORE_STATEMENT = /typecheck:\\s*ignore\\s+statement/i;\n  const PRAGMA_IGNORE_FILE = /typecheck:\\s*ignore\\s+file/i;\n  function skipEnvironment(comments, opts) {\n    if (!opts.only) {\n      return false;\n    }\n    const envs = pragmaEnvironments(comments);\n    return !opts.only.some(env => envs[env]);\n  }\n\n  function pragmaEnvironments(comments) {\n    const pragma = /@typecheck:\\s*(.+)/;\n    const environments = {};\n    comments.forEach(comment => {\n      const m = comment.value.match(pragma);\n      if (m) {\n        m[1].split(',').forEach(env => environments[env.trim()] = true);\n      }\n    })\n    return environments;\n  }\n\n  const visitors = {\n    Statement (path: NodePath): void {\n      maybeSkip(path);\n    },\n    TypeAlias (path: NodePath): void {\n      if (maybeSkip(path)) {\n        return;\n      }\n      path.replaceWith(createTypeAliasChecks(path));\n    },\n\n    InterfaceDeclaration (path: NodePath): void {\n      if (maybeSkip(path)) {\n        return;\n      }\n      path.replaceWith(createInterfaceChecks(path));\n    },\n\n    ExportNamedDeclaration (path: NodePath): void {\n      if (maybeSkip(path)) {\n        return;\n      }\n      const {node, scope} = path;\n      if (node.declaration && node.declaration.type === 'TypeAlias') {\n        path.replaceWith(t.exportNamedDeclaration(\n          createTypeAliasChecks(path.get('declaration')),\n          [],\n          null\n        ));\n      }\n    },\n\n    ImportDeclaration (path: NodePath): void {\n      if (maybeSkip(path)) {\n        return;\n      }\n      if (path.node.importKind !== 'type') {\n        return;\n      }\n      const [declarators, specifiers] = path.get('specifiers')\n        .map(specifier => {\n          const local = specifier.get('local');\n          const tmpId = path.scope.generateUidIdentifierBasedOnNode(local.node);\n          const replacement = t.importSpecifier(tmpId, specifier.node.imported);\n          const id = t.identifier(local.node.name);\n\n          id.isTypeChecker = true;\n          const declarator = t.variableDeclarator(id, tmpId);\n          declarator.isTypeChecker = true;\n          return [declarator, replacement];\n        })\n        .reduce(([declarators, specifiers], [declarator, specifier]) => {\n          declarators.push(declarator);\n          specifiers.push(specifier);\n          return [declarators, specifiers];\n        }, [[], []]);\n\n      const declaration = t.variableDeclaration('var', declarators);\n      declaration.isTypeChecker = true;\n\n      path.replaceWithMultiple([\n        t.importDeclaration(specifiers, path.node.source),\n        declaration\n      ]);\n    },\n\n    ArrowFunctionExpression (path: NodePath) {\n      // Look for destructuring args with annotations.\n\n      const params: NodePath[] = path.get('params');\n      for (let param of params) {\n        if (param.isObjectPattern() && param.node.typeAnnotation) {\n          const {scope} = path.get('body');\n          const id = scope.generateUidIdentifier(`arg${param.key}`);\n          const pattern = param.node;\n          param.replaceWith(id);\n          if (path.node.expression) {\n            const block = t.blockStatement([\n              t.variableDeclaration('var', [\n                t.variableDeclarator(pattern, id)\n              ]),\n              t.returnStatement(path.get('body').node)\n            ]);\n            path.node.body = block;\n            path.node.expression = false;\n          }\n          else {\n            path.get('body.body')[0].insertBefore(t.variableDeclaration('var', [\n              t.variableDeclarator(pattern, id)\n            ]));\n          }\n        }\n      }\n    },\n\n    Function: {\n      enter (path: NodePath, context: VisitorContext): void {\n        if (maybeSkip(path)) {\n          return;\n        }\n\n        const {node, scope} = path;\n        const paramChecks = collectParamChecks(path, context);\n        if (node.type === \"ArrowFunctionExpression\" && node.expression) {\n          node.expression = false;\n          node.body = t.blockStatement([t.returnStatement(node.body)]);\n        }\n        if (node.returnType) {\n          createFunctionReturnGuard(path, context);\n          createFunctionYieldGuards(path, context);\n        }\n        node.body.body.unshift(...paramChecks);\n        node.savedTypeAnnotation = node.returnType;\n        node.returnCount = 0;\n        node.yieldCount = 0;\n      },\n      exit (path: NodePath): void {\n        const {node, scope} = path;\n        const isVoid = node.savedTypeAnnotation ? maybeNullableAnnotation(node.savedTypeAnnotation) : null;\n        if (!node.returnCount && isVoid === false) {\n          let annotation = node.savedTypeAnnotation;\n          if (annotation.type === 'TypeAnnotation') {\n            annotation = annotation.typeAnnotation;\n          }\n          if (node.generator && isGeneratorAnnotation(annotation) && annotation.typeParameters && annotation.typeParameters.params.length > 1) {\n            annotation = annotation.typeParameters.params[1];\n          }\n          throw path.buildCodeFrameError(\n            buildErrorMessage(\n              `Function ${node.id ? `\"${node.id.name}\" ` : ''}did not return a value.`,\n              annotation\n            )\n          );\n        }\n        if (node.nextGuardCount) {\n          path.get('body').get('body')[0].insertBefore(node.nextGuard);\n        }\n        if (node.yieldGuardCount) {\n          path.get('body').get('body')[0].insertBefore(node.yieldGuard);\n        }\n        if (node.returnGuardCount) {\n          path.get('body').get('body')[0].insertBefore(node.returnGuard);\n        }\n      }\n    },\n\n    YieldExpression (path: NodePath, context: VisitorContext): void {\n      const fn = path.getFunctionParent();\n      if (!fn) {\n        return;\n      }\n      fn.node.yieldCount++;\n      if (!isGeneratorAnnotation(fn.node.returnType) || maybeSkip(path)) {\n        return;\n      }\n      const {node, parent, scope} = path;\n      let annotation = fn.node.returnType;\n      if (annotation.type === 'NullableTypeAnnotation' || annotation.type === 'TypeAnnotation') {\n        annotation = annotation.typeAnnotation;\n      }\n      if (!annotation.typeParameters || annotation.typeParameters.params.length === 0) {\n        return;\n      }\n\n      const yieldType = annotation.typeParameters.params[0];\n      const nextType = annotation.typeParameters.params[2];\n      const ok = staticCheckAnnotation(path.get(\"argument\"), yieldType);\n      if (ok === true && !nextType) {\n        return;\n      }\n      else if (ok === false) {\n        throw path.buildCodeFrameError(\n          buildErrorMessage(\n            `Function ${fn.node.id ? `\"${fn.node.id.name}\" ` : ''}yielded an invalid type.`,\n            yieldType,\n            getAnnotation(path.get('argument'))\n          )\n        );\n      }\n      fn.node.yieldGuardCount++;\n      if (fn.node.yieldGuard) {\n        const yielder = t.yieldExpression(\n          t.callExpression(fn.node.yieldGuardName, [node.argument || t.identifier('undefined')])\n        );\n        yielder.hasBeenTypeChecked = true;\n\n        if (fn.node.nextGuard) {\n          fn.node.nextGuardCount++;\n          path.replaceWith(t.callExpression(fn.node.nextGuardName, [yielder]));\n        }\n        else {\n          path.replaceWith(yielder);\n        }\n      }\n      else if (fn.node.nextGuard) {\n        fn.node.nextGuardCount++;\n        path.replaceWith(t.callExpression(fn.node.nextGuardName, [yielder]));\n      }\n    },\n\n\n    ReturnStatement (path: NodePath, context: VisitorContext): void {\n      const fn = path.getFunctionParent();\n      if (!fn) {\n        return;\n      }\n      fn.node.returnCount++;\n      if (maybeSkip(path)) {\n        return;\n      }\n      const {node, parent, scope} = path;\n      const {returnType, returnGuardName} = fn.node;\n      if (!returnType || !returnGuardName) {\n        return;\n      }\n      if (!node.argument) {\n        if (maybeNullableAnnotation(returnType) === false) {\n          throw path.buildCodeFrameError(\n            buildErrorMessage(\n              `Function ${fn.node.id ? `\"${fn.node.id.name}\" ` : ''}did not return a value.`,\n              returnType\n            )\n          );\n        }\n        return;\n      }\n      let annotation = returnType;\n      if (annotation.type === 'TypeAnnotation') {\n        annotation = annotation.typeAnnotation;\n      }\n      if (isGeneratorAnnotation(annotation)) {\n        annotation = annotation.typeParameters && annotation.typeParameters.params.length > 1 ? annotation.typeParameters.params[1] : t.anyTypeAnnotation();\n      }\n      else if (node.async && annotation.type === 'GenericTypeAnnotation' && annotation.id.name === 'Promise') {\n        annotation = (annotation.typeParameters && annotation.typeParameters[0]) || t.anyTypeAnnotation();\n      }\n      const ok = staticCheckAnnotation(path.get(\"argument\"), annotation);\n      if (ok === true) {\n        return;\n      }\n      else if (ok === false) {\n        throw path.buildCodeFrameError(\n          buildErrorMessage(\n            `Function ${fn.node.id ? `\"${fn.node.id.name}\" ` : ''}returned an invalid type.`,\n            annotation,\n            getAnnotation(path.get('argument'))\n          )\n        );\n      }\n      fn.node.returnGuardCount++;\n      const returner = t.returnStatement(t.callExpression(fn.node.returnGuardName, [node.argument]));\n      returner.hasBeenTypeChecked = true;\n      path.replaceWith(returner);\n    },\n\n    VariableDeclaration (path: NodePath, context: VisitorContext): void {\n      if (maybeSkip(path)) {\n        return;\n      }\n      const {node, scope} = path;\n      const collected = [];\n      const declarations = path.get(\"declarations\");\n      for (let i = 0; i < node.declarations.length; i++) {\n        const declaration = node.declarations[i];\n        const {id, init} = declaration;\n        if (!id.typeAnnotation || id.hasBeenTypeChecked) {\n          continue;\n        }\n        id.savedTypeAnnotation = id.typeAnnotation;\n        id.hasBeenTypeChecked = true;\n        const ok = staticCheckAnnotation(declarations[i], id.typeAnnotation);\n        if (ok === true) {\n          continue;\n        }\n        else if (ok === false) {\n          throw path.buildCodeFrameError(\n            buildErrorMessage(\n              `Invalid assignment value for \"${id.name}\".`,\n              id.typeAnnotation,\n              getAnnotation(declarations[i])\n            )\n          );\n        }\n        const check = checkAnnotation(id, id.typeAnnotation, scope);\n        if (check) {\n          collected.push(guard({\n            check,\n            message: varTypeErrorMessage(id, context)\n          }));\n        }\n      }\n      if (collected.length > 0) {\n        const check = collected.reduce((check, branch) => {\n          branch.alternate = check;\n          return branch;\n        });\n        if (path.parent.type === 'Program' || path.parent.type === 'BlockStatement') {\n          path.insertAfter(check);\n        }\n        else if (path.parentPath.isForXStatement() || path.parentPath.isForStatement() || path.parentPath.isForInStatement()) {\n          let body = path.parentPath.get('body');\n          if (body.type !== 'BlockStatement') {\n            const block = t.blockStatement([body.node]);\n            body.replaceWith(block);\n            body = path.parentPath.get('body');\n          }\n          const children = body.get('body');\n          if (children.length === 0) {\n            body.replaceWith(check);\n          }\n          else {\n            children[0].insertBefore(check);\n          }\n\n        }\n        else if (path.parent.type === 'ExportNamedDeclaration' || path.parent.type === 'ExportDefaultDeclaration' || path.parent.type === 'ExportAllDeclaration') {\n          path.parentPath.insertAfter(check);\n        }\n        else {\n          path.replaceWith(t.blockStatement([node, check]));\n        }\n      }\n    },\n\n    AssignmentExpression (path: NodePath, context: VisitorContext): void {\n      if (maybeSkip(path)) {\n        return;\n      }\n      const {node, scope} = path;\n      const left = path.get('left');\n      let annotation;\n      if (node.hasBeenTypeChecked || node.left.hasBeenTypeChecked) {\n        return;\n      }\n      else if (left.isMemberExpression()) {\n        annotation = getAnnotation(left);\n      }\n      else if (t.isIdentifier(node.left)) {\n        const binding = scope.getBinding(node.left.name);\n        if (!binding) {\n          return;\n        }\n        else if (binding.path.type !== 'VariableDeclarator') {\n          return;\n        }\n        annotation = left.getTypeAnnotation();\n        if (annotation.type === 'AnyTypeAnnotation') {\n          const item = binding.path.get('id');\n          annotation = item.node.savedTypeAnnotation || item.getTypeAnnotation();\n        }\n      }\n      else {\n        return;\n      }\n\n      node.hasBeenTypeChecked = true;\n      node.left.hasBeenTypeChecked = true;\n      const id = node.left;\n      const right = path.get('right');\n      if (annotation.type === 'AnyTypeAnnotation') {\n        return;\n      }\n      const ok = staticCheckAnnotation(right, annotation);\n      if (ok === true) {\n        return;\n      }\n      else if (ok === false) {\n        throw path.buildCodeFrameError(\n          buildErrorMessage(\n            `Invalid assignment value for \"${humanReadableType(id)}\".`,\n            annotation,\n            getAnnotation(right)\n          )\n        );\n      }\n      const check = checkAnnotation(id, annotation, scope);\n      if (!id.typeAnnotation) {\n        id.typeAnnotation = annotation;\n      }\n      id.hasBeenTypeChecked = true;\n      if (check) {\n        const parent = path.getStatementParent();\n        parent.insertAfter(guard({\n          check,\n          message: varTypeErrorMessage(id, context)\n        }));\n      }\n    },\n\n    TypeCastExpression (path: NodePath): void {\n      const {node} = path;\n      let target;\n      switch (node.expression.type) {\n        case 'Identifier':\n          target = node.expression;\n          break;\n        case 'AssignmentExpression':\n          target = node.expression.left;\n          break;\n        default:\n          // unsupported.\n          return;\n      }\n      const id = path.scope.getBindingIdentifier(target.name);\n      if (!id) {\n        return;\n      }\n      id.savedTypeAnnotation = path.getTypeAnnotation();\n    },\n\n    ForOfStatement (path: NodePath, context: VisitorContext): void {\n      if (maybeSkip(path)) {\n        return;\n      }\n      const left: NodePath = path.get('left');\n      const right: NodePath = path.get('right');\n      const rightAnnotation: TypeAnnotation = getAnnotation(right);\n      const leftAnnotation: TypeAnnotation = left.isVariableDeclaration() ? getAnnotation(left.get('declarations')[0].get('id')) : getAnnotation(left);\n      if (rightAnnotation.type !== 'VoidTypeAnnotation' && rightAnnotation.type !== 'NullLiteralTypeAnnotation') {\n        const ok: ?boolean = maybeIterableAnnotation(rightAnnotation);\n        if (ok === false) {\n          throw path.buildCodeFrameError(`Cannot iterate ${humanReadableType(rightAnnotation)}.`);\n        }\n      }\n      let id: ?Identifier;\n      if (right.isIdentifier()) {\n        id = right.node;\n      }\n      else {\n        id = path.scope.generateUidIdentifierBasedOnNode(right.node);\n        path.scope.push({id});\n        const replacement: Node = t.expressionStatement(t.assignmentExpression('=', id, right.node));\n        path.insertBefore(replacement);\n        right.replaceWith(id);\n      }\n      path.insertBefore(guard({\n        check: checks.iterable({input: id}),\n        message: t.binaryExpression(\n          '+',\n          t.stringLiteral(`Expected ${humanReadableType(right.node)} to be iterable, got `),\n          readableName({inspect: context.inspect, input: id})\n        )\n      }));\n\n      if (rightAnnotation.type !== 'GenericTypeAnnotation' || rightAnnotation.id.name !== 'Iterable' || !rightAnnotation.typeParameters || !rightAnnotation.typeParameters.params.length) {\n        return;\n      }\n\n      const annotation: TypeAnnotation = rightAnnotation.typeParameters.params[0];\n      if (compareAnnotations(annotation, leftAnnotation) === false) {\n        throw path.buildCodeFrameError(\n          buildErrorMessage(\n            `Invalid iterator type.`,\n            annotation,\n            leftAnnotation\n          )\n        );\n      }\n    },\n\n    ClassDeclaration (path: NodePath, context: VisitorContext) {\n      // Convert React props to propTypes\n      if (!path.node.superClass) {\n        return;\n      }\n\n      let props: ?NodePath;\n      let hasRenderMethod = false;\n      for (let memberPath of path.get('body.body')) {\n        const classMember = memberPath.node;\n        if (t.isClassProperty(classMember)) {\n          if (classMember.key.name === 'propTypes' && classMember.static) {\n            return;\n          } \n          else if (classMember.key.name === 'props' && !classMember.static) {\n            props = memberPath;\n          }\n        }\n        if (t.isClassMethod(classMember) && classMember.key.name === 'render') {\n          hasRenderMethod = true;\n        }\n      }\n\n      let type: ?Node;\n      if (path.node.superTypeParameters) {\n        if (path.node.superTypeParameters.params.length !== 3) {\n          return;\n        }\n        type = path.node.superTypeParameters.params[1];\n      }\n      if (props) {\n        type = props.node.typeAnnotation.typeAnnotation;\n      }\n\n      if (!type || !hasRenderMethod) {\n        return;\n      }\n\n      if (t.isGenericTypeAnnotation(type)) {\n        const binding = path.scope.getBinding(type.id.name);\n        type = getAnnotation(binding.path);\n      }\n      if (!t.isObjectTypeAnnotation(type)) {\n        return;\n      }\n\n      // Now we have a class that has a superclass, an instance method called 'render'\n      // and some property type annotations. We can be reasonably sure it's a React component.\n\n      const propTypes = t.objectExpression(\n        type.properties.map(\n          prop => t.objectProperty(\n            t.identifier(prop.key.name),\n            generatePropType(prop.value, path.scope, context)\n          )\n        )\n      );\n\n      if (path.node.decorators) {\n        const property = t.classProperty(t.identifier('propTypes'), propTypes);\n        property.static = true;\n        props.insertAfter(property);\n      } \n      else {\n        const root:NodePath = path.parentPath.isExportDeclaration() ? path.parentPath : path;\n        root.insertAfter(\n          t.expressionStatement(\n            t.assignmentExpression(\n              \"=\",\n              t.memberExpression(path.node.id, t.identifier(\"propTypes\")),\n              propTypes\n            )\n          )\n        );\n      }\n    }\n  };\n\n  return {\n    visitor: {\n      Program (path: NodePath, {opts}) {\n        if (opts && opts.disable && opts.disable[process.env.NODE_ENV]) {\n          return;\n        }\n        let checkFile = false;\n        for (let child of path.get('body')) {\n          if (mustCheckFile(child, opts)) {\n            checkFile = true;\n            break;\n          }\n        }\n        if (!checkFile) {\n          for (let child of path.get('body')) {\n            if (maybeSkipFile(child, opts)) {\n              return;\n            }\n          }\n        }\n        const inspect = path.scope.generateUidIdentifier('inspect');\n        const requiresHelpers = {\n          inspect: false\n        };\n        const context = {\n          get inspect () {\n            requiresHelpers.inspect = true;\n            return inspect;\n          }\n        };\n        path.traverse(visitors, context);\n\n        if (requiresHelpers.inspect) {\n          const body = path.get('body');\n          body[body.length - 1].insertAfter(template(`\n            function id (input, depth) {\n              const maxDepth = 4;\n              const maxKeys = 15;\n              if (depth === undefined) {\n                depth = 0;\n              }\n              depth += 1;\n              if (input === null) {\n                return 'null';\n              }\n              else if (input === undefined) {\n                return 'void';\n              }\n              else if (typeof input === 'string' || typeof input === 'number' || typeof input === 'boolean') {\n                return typeof input;\n              }\n              else if (Array.isArray(input)) {\n                if (input.length > 0) {\n                  if (depth > maxDepth) return '[...]';\n                  const first = id(input[0], depth);\n                  if (input.every(item => id(item, depth) === first)) {\n                    return first.trim() + '[]';\n                  }\n                  else {\n                    return '[' + input.slice(0, maxKeys).map(item => id(item, depth)).join(', ') + (input.length >= maxKeys ? ', ...' : '') + ']';\n                  }\n                }\n                else {\n                  return 'Array';\n                }\n              }\n              else {\n                const keys = Object.keys(input);\n                if (!keys.length) {\n                  if (input.constructor && input.constructor.name && input.constructor.name !== 'Object') {\n                    return input.constructor.name;\n                  }\n                  else {\n                    return 'Object';\n                  }\n                }\n                if (depth > maxDepth) return '{...}';\n                const indent = '  '.repeat(depth - 1);\n                let entries = keys.slice(0, maxKeys).map(key => {\n                  return (/^([A-Z_$][A-Z0-9_$]*)$/i.test(key) ? key : JSON.stringify(key)) + ': ' + id(input[key], depth) + ';';\n                }).join('\\\\n  ' + indent);\n                if (keys.length >= maxKeys) {\n                  entries += '\\\\n  ' + indent + '...';\n                }\n                if (input.constructor && input.constructor.name && input.constructor.name !== 'Object') {\n                  return input.constructor.name + ' {\\\\n  ' + indent + entries + '\\\\n' + indent + '}';\n                }\n                else {\n                  return '{\\\\n  ' + indent + entries + '\\\\n' + indent + '}';\n                }\n              }\n            }\n          `)({id: inspect}));\n        }\n      }\n    }\n  }\n\n  /**\n   * Create a function which can verify the return type for a function.\n   */\n  function createFunctionReturnGuard (path: NodePath, context: VisitorContext): void {\n    const {node, scope} = path;\n    let annotation = node.returnType;\n    if (annotation.type === 'TypeAnnotation') {\n      annotation = annotation.typeAnnotation;\n    }\n    if (isGeneratorAnnotation(annotation)) {\n      annotation = annotation.typeParameters && annotation.typeParameters.params.length > 1 ? annotation.typeParameters.params[1] : t.anyTypeAnnotation();\n    }\n    else if (node.async && annotation.type === 'GenericTypeAnnotation' && annotation.id.name === 'Promise') {\n      annotation = (annotation.typeParameters && annotation.typeParameters[0]) || t.anyTypeAnnotation();\n    }\n    const name = scope.generateUidIdentifierBasedOnNode(node);\n    const id = scope.generateUidIdentifier('id');\n    const check = checkAnnotation(id, annotation, scope);\n    if (check) {\n      node.returnGuard = guardFn({\n        id,\n        name,\n        check,\n        message: returnTypeErrorMessage(path, path.node, id, context)\n      });\n      node.returnGuard.hasBeenTypeChecked = true;\n      node.returnGuardName = name;\n      node.returnGuardCount = 0;\n    }\n  }\n\n  function createFunctionYieldGuards (path: NodePath, context: VisitorContext) {\n    const {node, scope} = path;\n    let annotation = node.returnType;\n    if (annotation.type === 'NullableTypeAnnotation' || annotation.type === 'TypeAnnotation') {\n      annotation = annotation.typeAnnotation;\n    }\n    if (!annotation.typeParameters || annotation.typeParameters.params.length === 0) {\n      return;\n    }\n    if (annotation.type === 'TypeAnnotation') {\n      annotation = annotation.typeAnnotation;\n    }\n    if (!isGeneratorAnnotation(annotation)) {\n      return;\n    }\n\n    const yieldType = annotation.typeParameters.params[0];\n    const nextType = annotation.typeParameters.params[2];\n\n    if (yieldType) {\n      const name = scope.generateUidIdentifier(`check${node.id ? node.id.name.slice(0, 1).toUpperCase() + node.id.name.slice(1) : ''}Yield`);\n      const id = scope.generateUidIdentifier('id');\n      const check = checkAnnotation(id, yieldType, scope);\n      if (check) {\n        node.yieldGuard = guardFn({\n          id,\n          name,\n          check,\n          message: yieldTypeErrorMessage(node, yieldType, id, context)\n        });\n        node.yieldGuardName = name;\n        node.yieldGuardCount = 0;\n      }\n    }\n\n\n    if (nextType) {\n      const name = scope.generateUidIdentifier(`check${node.id ? node.id.name.slice(0, 1).toUpperCase() + node.id.name.slice(1) : ''}Next`);\n      const id = scope.generateUidIdentifier('id');\n      const check = checkAnnotation(id, nextType, scope);\n      if (check) {\n        node.nextGuard = guardFn({\n          id,\n          name,\n          check,\n          message: yieldNextTypeErrorMessage(node, nextType, id, context)\n        });\n        node.nextGuardName = name;\n        node.nextGuardCount = 0;\n      }\n    }\n  }\n\n  function isThisMemberExpression (path: NodePath): boolean {\n    const {node} = path;\n    if (node.type === 'ThisExpression') {\n      return true;\n    }\n    else if (node.type === 'MemberExpression') {\n      return isThisMemberExpression(path.get('object'));\n    }\n    else {\n      return false;\n    }\n  }\n\n  function isGeneratorAnnotation (annotation: ?TypeAnnotation): boolean {\n    if (!annotation) {\n      return false;\n    }\n    if (annotation.type === 'TypeAnnotation' || annotation.type === 'NullableTypeAnnotation') {\n      annotation = annotation.typeAnnotation;\n    }\n    return annotation.type === 'GenericTypeAnnotation' && annotation.id.name === 'Generator';\n  }\n\n  function buildErrorMessage (message: string, expected: TypeAnnotation, got: ?Node) {\n    if (got) {\n      return message + '\\n\\nExpected:\\n' + humanReadableType(expected) + '\\n\\nGot:\\n' + humanReadableType(got);\n    }\n    else {\n      return message + '\\n\\nExpected:\\n' + humanReadableType(expected);\n    }\n  }\n\n  function createChecks (): Object {\n    return {\n      number: expression(`typeof input === 'number'`),\n      numericLiteral: checkNumericLiteral,\n      boolean: expression(`typeof input === 'boolean'`),\n      booleanLiteral: checkBooleanLiteral,\n      class: checkClass,\n      function: expression(`typeof input === 'function'`),\n      string: expression(`typeof input === 'string'`),\n      stringLiteral: checkStringLiteral,\n      symbol: expression(`typeof input === 'symbol'`),\n      undefined: expression(`input === undefined`),\n      null: expression(`input === null`),\n      void: expression(`input == null`),\n      instanceof: expression(`input instanceof type`),\n      type: expression(`type(input)`),\n      mixed: () => null,\n      any: () => null,\n      union: checkUnion,\n      intersection: checkIntersection,\n      array: checkArray,\n      map: checkMap,\n      set: checkSet,\n      generator: checkGenerator,\n      iterable: checkIterable,\n      tuple: checkTuple,\n      object: checkObject,\n      nullable: checkNullable,\n      typeof: checkTypeof,\n      int8: expression(`typeof input === 'number' && !isNaN(input) && input >= -128 && input <= 127 && input === Math.floor(input)`),\n      uint8: expression(`typeof input === 'number' && !isNaN(input) && input >= 0 && input <= 255 && input === Math.floor(input)`),\n      int16: expression(`typeof input === 'number' && !isNaN(input) && input >= -32768 && input <= 32767 && input === Math.floor(input)`),\n      uint16: expression(`typeof input === 'number' && !isNaN(input) && input >= 0 && input <= 65535 && input === Math.floor(input)`),\n      int32: expression(`typeof input === 'number' && !isNaN(input) && input >= -2147483648 && input <= 2147483647 && input === Math.floor(input)`),\n      uint32: expression(`typeof input === 'number' && !isNaN(input) && input >= 0 && input <= 4294967295 && input === Math.floor(input)`),\n      float32: expression(`typeof input === 'number' && !isNaN(input) && input >= -3.40282347e+38 && input <= 3.40282347e+38`),\n      float64: expression(`typeof input === 'number' && !isNaN(input)`),\n      double: expression(`typeof input === 'number' && !isNaN(input)`)\n\n\n    };\n  }\n\n  function createStaticChecks (): Object {\n    return {\n      symbol (path: NodePath): ?boolean {\n        return maybeSymbolAnnotation(getAnnotation(path));\n      },\n      instanceof ({path, annotation}): ?boolean {\n        const type = createTypeExpression(annotation.id);\n\n        const {node, scope} = path;\n        if (type.name === 'Object' && node.type === 'ObjectExpression' && !scope.getBinding('Object')) {\n          return true;\n        }\n        else if (type.name === 'Map' && !scope.getBinding('Map')) {\n          return null;\n        }\n        else if (type.name === 'Set' && !scope.getBinding('Set')) {\n          return null;\n        }\n        else if (type.name === 'Class' && !scope.hasBinding('Class')) {\n          return null;\n        }\n        else if (type.name === 'int8' && !scope.hasBinding('int8')) {\n          return null;\n        }\n        else if (type.name === 'uint8' && !scope.hasBinding('uint8')) {\n          return null;\n        }\n        else if (type.name === 'int16' && !scope.hasBinding('int16')) {\n          return null;\n        }\n        else if (type.name === 'uint16' && !scope.hasBinding('uint16')) {\n          return null;\n        }\n        else if (type.name === 'int32' && !scope.hasBinding('int32')) {\n          return null;\n        }\n        else if (type.name === 'uint32' && !scope.hasBinding('uint32')) {\n          return null;\n        }\n        else if (type.name === 'float32' && !scope.hasBinding('float32')) {\n          return null;\n        }\n        else if (type.name === 'float64' && !scope.hasBinding('float64')) {\n          return null;\n        }\n        else if (type.name === 'double' && !scope.hasBinding('double')) {\n          return null;\n        }\n        return maybeInstanceOfAnnotation(getAnnotation(path), type, annotation.typeParameters ? annotation.typeParameters.params : []);\n      },\n      type ({path, type}): ?boolean {\n        return null;\n      },\n    };\n  }\n\n  function compareAnnotations (a: TypeAnnotation, b: TypeAnnotation): ?boolean {\n    if (a.type === 'TypeAnnotation') {\n      a = a.typeAnnotation;\n    }\n    if (b.type === 'TypeAnnotation') {\n      b = b.typeAnnotation;\n    }\n    switch (a.type) {\n      case 'StringTypeAnnotation':\n        return maybeStringAnnotation(b);\n      case 'StringLiteral':\n      case 'StringLiteralTypeAnnotation':\n        return compareStringLiteralAnnotations(a, b);\n      case 'NumberTypeAnnotation':\n        return maybeNumberAnnotation(b);\n      case 'NumericLiteral':\n      case 'NumericLiteralTypeAnnotation':\n        return compareNumericLiteralAnnotations(a, b);\n      case 'BooleanTypeAnnotation':\n        return maybeBooleanAnnotation(b);\n      case 'BooleanLiteral':\n      case 'BooleanLiteralTypeAnnotation':\n        return compareBooleanLiteralAnnotations(a, b);\n      case 'FunctionTypeAnnotation':\n        return maybeFunctionAnnotation(b);\n      case 'AnyTypeAnnotation':\n        return null;\n      case 'MixedTypeAnnotation':\n        return null;\n      case 'ObjectTypeAnnotation':\n        return compareObjectAnnotation(a, b);\n      case 'ArrayTypeAnnotation':\n        return compareArrayAnnotation(a, b);\n      case 'GenericTypeAnnotation':\n        return compareGenericAnnotation(a, b);\n      case 'TupleTypeAnnotation':\n        return compareTupleAnnotation(a, b);\n      case 'UnionTypeAnnotation':\n        return compareUnionAnnotation(a, b);\n      case 'IntersectionTypeAnnotation':\n        return compareIntersectionAnnotation(a, b);\n      case 'NullableTypeAnnotation':\n        return compareNullableAnnotation(a, b);\n      default:\n        return null;\n    }\n  }\n\n  function compareStringLiteralAnnotations (a: StringLiteralTypeAnnotation, b: TypeAnnotation): ?boolean {\n    if (b.type === 'StringLiteralTypeAnnotation' || b.type === 'StringLiteral') {\n      return a.value === b.value;\n    }\n    else {\n      return maybeStringAnnotation(b) === false ? false : null;\n    }\n  }\n\n  function compareBooleanLiteralAnnotations (a: BooleanLiteralTypeAnnotation, b: TypeAnnotation): ?boolean {\n    if (b.type === 'BooleanLiteralTypeAnnotation' || b.type === 'BooleanLiteral') {\n      return a.value === b.value;\n    }\n    else {\n      return maybeBooleanAnnotation(b) === false ? false : null;\n    }\n  }\n\n  function compareNumericLiteralAnnotations (a: NumericLiteralTypeAnnotation, b: TypeAnnotation): ?boolean {\n    if (b.type === 'NumericLiteralTypeAnnotation' || b.type === 'NumericLiteral') {\n      return a.value === b.value;\n    }\n    else {\n      return maybeNumberAnnotation(b) === false ? false : null;\n    }\n  }\n\n  function unionComparer (a: TypeAnnotation, b: TypeAnnotation, comparator: (a:TypeAnnotation, b:TypeAnnotation) => ?boolean): ?boolean {\n    if (!a.types || a.types.length === 0) {\n      return null;\n    }\n    let falseCount = 0;\n    let trueCount = 0;\n    if (!a.types) {\n      return null;\n    }\n    for (let type of a.types) {\n      const result = comparator(type, b);\n      if (result === true) {\n        if (b.type !== 'UnionTypeAnnotation') {\n          return true;\n        }\n        trueCount++;\n      }\n      else if (result === false) {\n        if (b.type === 'UnionTypeAnnotation') {\n          return false;\n        }\n        falseCount++;\n      }\n    }\n    if (falseCount === a.types.length) {\n      return false;\n    }\n    else if (trueCount === a.types.length) {\n      return true;\n    }\n    else {\n      return null;\n    }\n  }\n\n  function intersectionComparer (a: TypeAnnotation, b: TypeAnnotation, comparator: (a:TypeAnnotation, b:TypeAnnotation) => ?boolean): ?boolean {\n    let falseCount = 0;\n    let trueCount = 0;\n    if (!a.types) {\n      return null;\n    }\n    for (let type of a.types) {\n      const result = comparator(type, b);\n      if (result === true) {\n        trueCount++;\n      }\n      else if (result === false) {\n        return false;\n      }\n    }\n    if (trueCount === a.types.length) {\n      return true;\n    }\n    else {\n      return null;\n    }\n  }\n\n  function compareObjectAnnotation (a: Node, b: Node): ?boolean {\n    switch (b.type) {\n      case 'ObjectTypeAnnotation':\n        break;\n      case 'TypeAnnotation':\n      case 'FunctionTypeParam':\n      case 'NullableTypeAnnotation':\n        return compareObjectAnnotation(a, b.typeAnnotation);\n      case 'UnionTypeAnnotation':\n        return unionComparer(a, b, compareObjectAnnotation);\n      case 'IntersectionTypeAnnotation':\n        return intersectionComparer(a, b, compareObjectAnnotation);\n      case 'VoidTypeAnnotation':\n      case 'NullLiteralTypeAnnotation':\n      case 'BooleanTypeAnnotation':\n      case 'BooleanLiteralTypeAnnotation':\n      case 'StringTypeAnnotation':\n      case 'StringLiteralTypeAnnotation':\n      case 'NumberTypeAnnotation':\n      case 'NumericLiteralTypeAnnotation':\n      case 'FunctionTypeAnnotation':\n        return false;\n      default:\n        return null;\n    }\n\n    // We're comparing two object annotations.\n    let allTrue = true;\n    for (let aprop of a.properties) {\n      let found = false;\n      for (let bprop of b.properties) {\n        if (bprop.key.name === aprop.key.name) {\n          const result = compareAnnotations(aprop.value, bprop.value);\n          if (result === false && !(aprop.optional && (bprop.optional || maybeNullableAnnotation(bprop.value) === true))) {\n            return false;\n          }\n          else {\n            found = result;\n          }\n          break;\n        }\n      }\n      if (found === false && !aprop.optional) {\n        return false;\n      }\n      allTrue = allTrue && found === true;\n    }\n    return allTrue ? true : null;\n  }\n\n  function compareArrayAnnotation (a: Node, b: Node): ?boolean {\n    switch (b.type) {\n      case 'TypeAnnotation':\n      case 'FunctionTypeParam':\n      case 'NullableTypeAnnotation':\n        return compareArrayAnnotation(a, b.typeAnnotation);\n      case 'UnionTypeAnnotation':\n        return unionComparer(a, b, compareArrayAnnotation);\n      case 'IntersectionTypeAnnotation':\n        return intersectionComparer(a, b, compareArrayAnnotation);\n      case 'VoidTypeAnnotation':\n      case 'NullLiteralTypeAnnotation':\n      case 'BooleanTypeAnnotation':\n      case 'BooleanLiteralTypeAnnotation':\n      case 'StringTypeAnnotation':\n      case 'StringLiteralTypeAnnotation':\n      case 'NumberTypeAnnotation':\n      case 'NumericLiteralTypeAnnotation':\n      case 'FunctionTypeAnnotation':\n        return false;\n      default:\n        return null;\n    }\n  }\n\n  function compareGenericAnnotation (a: Node, b: Node): ?boolean {\n    switch (b.type) {\n      case 'TypeAnnotation':\n      case 'FunctionTypeParam':\n      case 'NullableTypeAnnotation':\n        return compareGenericAnnotation(a, b.typeAnnotation);\n      case 'GenericTypeAnnotation':\n        if (b.id.name === a.id.name) {\n          return true;\n        }\n        else {\n          return null;\n        }\n      case 'UnionTypeAnnotation':\n        return unionComparer(a, b, compareGenericAnnotation);\n      case 'IntersectionTypeAnnotation':\n        return intersectionComparer(a, b, compareGenericAnnotation);\n      default:\n        return null;\n    }\n  }\n\n  function compareTupleAnnotation (a: Node, b: Node): ?boolean {\n    if (b.type === 'TupleTypeAnnotation') {\n      if (b.types.length === 0) {\n        return null;\n      }\n      else if (b.types.length < a.types.length) {\n        return false;\n      }\n      return a.types.every((type, index) => compareAnnotations(type, b.types[index]));\n    }\n    switch (b.type) {\n      case 'TypeAnnotation':\n      case 'FunctionTypeParam':\n      case 'NullableTypeAnnotation':\n        return compareTupleAnnotation(a, b.typeAnnotation);\n      case 'UnionTypeAnnotation':\n        return unionComparer(a, b, compareTupleAnnotation);\n      case 'IntersectionTypeAnnotation':\n        return intersectionComparer(a, b, compareTupleAnnotation);\n      case 'VoidTypeAnnotation':\n      case 'NullLiteralTypeAnnotation':\n      case 'BooleanTypeAnnotation':\n      case 'BooleanLiteralTypeAnnotation':\n      case 'StringTypeAnnotation':\n      case 'StringLiteralTypeAnnotation':\n      case 'NumberTypeAnnotation':\n      case 'NumericLiteralTypeAnnotation':\n      case 'FunctionTypeAnnotation':\n        return false;\n      default:\n        return null;\n    }\n  }\n\n  function compareUnionAnnotation (a: Node, b: Node): ?boolean {\n    switch (b.type) {\n      case 'NullableTypeAnnotation':\n        return compareUnionAnnotation(a, b.typeAnnotation);\n      case 'AnyTypeAnnotation':\n      case 'MixedTypeAnnotation':\n        return null;\n      default:\n        return unionComparer(a, b, compareAnnotations);\n    }\n  }\n\n  function compareNullableAnnotation (a: Node, b: Node): ?boolean {\n    switch (b.type) {\n      case 'TypeAnnotation':\n      case 'FunctionTypeParam':\n        return compareNullableAnnotation(a, b.typeAnnotation);\n      case 'NullableTypeAnnotation':\n      case 'VoidTypeAnnotation':\n      case 'NullLiteralTypeAnnotation':\n        return null;\n    }\n    if (compareAnnotations(a.typeAnnotation, b) === true) {\n      return true;\n    }\n    else {\n      return null;\n    }\n  }\n\n  function arrayExpressionToTupleAnnotation (path: NodePath): TypeAnnotation {\n    const elements = path.get('elements');\n    return t.tupleTypeAnnotation(elements.map(element => getAnnotation(element)));\n  }\n\n  function checkNullable ({input, type, scope}): ?Node {\n    const check = checkAnnotation(input, type, scope);\n    if (!check) {\n      return;\n    }\n    return t.logicalExpression(\n      \"||\",\n      checks.void({input}),\n      check\n    );\n  }\n\n  function checkTypeof ({input, annotation, scope}): ?Node {\n    switch (annotation.type) {\n      case 'GenericTypeAnnotation':\n        const {id} = annotation;\n        const path = Object.assign({}, input, {type: id.type, node: id, scope});\n        return checkAnnotation(input, getAnnotation(path), scope);\n      default:\n        return checkAnnotation(input, annotation, scope);\n    }\n  }\n\n  function checkStringLiteral ({input, annotation}): ?Node {\n    return checkEquals({input, expected: t.stringLiteral(annotation.value)});\n  }\n\n  function checkNumericLiteral ({input, annotation}): ?Node {\n    return checkEquals({input, expected: t.numericLiteral(annotation.value)});\n  }\n\n  function checkBooleanLiteral ({input, annotation}): ?Node {\n    return checkEquals({input, expected: t.booleanLiteral(annotation.value)});\n  }\n\n  function checkUnion ({input, types, scope}): ?Node {\n    const checks = types.map(type => checkAnnotation(input, type, scope)).filter(identity);\n    return checks.reduce((last, check, index) => {\n      if (last == null) {\n        return check;\n      }\n      return t.logicalExpression(\n        \"||\",\n        last,\n        check\n      );\n    }, null);\n  }\n\n\n  function checkIntersection ({input, types, scope}): ?Node {\n    const checks = types.map(type => checkAnnotation(input, type, scope)).filter(identity);\n    return checks.reduce((last, check, index) => {\n      if (last == null) {\n        return check;\n      }\n      return t.logicalExpression(\n        \"&&\",\n        last,\n        check\n      );\n    }, null);\n  }\n\n\n  function checkMap ({input, types, scope}): Node {\n    const [keyType, valueType] = types;\n    const key = t.identifier('key');\n    const value = t.identifier('value');\n    const keyCheck = keyType ? checkAnnotation(key, keyType, scope) : null;\n    const valueCheck = valueType ? checkAnnotation(value, valueType, scope) : null;\n    if (!keyCheck) {\n      if (!valueCheck) {\n        return checkIsMap({input});\n      }\n      else {\n        return checkMapValues({input, value, valueCheck});\n      }\n    }\n    else {\n      if (!valueCheck) {\n        return checkMapKeys({input, key, keyCheck});\n      }\n      else {\n        return checkMapEntries({input, key, value, keyCheck, valueCheck});\n      }\n    }\n  }\n\n  function checkSet ({input, types, scope}): Node {\n    const [valueType] = types;\n    const value = t.identifier('value');\n    const valueCheck = valueType ? checkAnnotation(value, valueType, scope) : null;\n    if (!valueCheck) {\n      return checkIsSet({input});\n    }\n    else {\n      return checkSetEntries({input, value, valueCheck});\n    }\n  }\n\n  function checkGenerator ({input, types, scope}): Node {\n    return checkIsGenerator({input});\n  }\n\n  function checkIterable ({input, types, scope}): Node {\n    return checkIsIterable({input});\n  }\n\n  function checkClass ({input, types, scope}): Node {\n    return checkIsClass({input});\n  }\n\n  function checkArray ({input, types, scope}): Node {\n    if (!types || types.length === 0) {\n      return checkIsArray({input});\n    }\n    else if (types.length === 1) {\n      const item = t.identifier('item');\n      const type = types[0];\n      const check = checkAnnotation(item, type, scope);\n      if (!check) {\n        return checkIsArray({input});\n      }\n      return t.logicalExpression(\n        '&&',\n        checkIsArray({input}),\n        t.callExpression(\n          t.memberExpression(input, t.identifier('every')),\n          [t.functionExpression(null, [item], t.blockStatement([\n            t.returnStatement(check)\n          ]))]\n        )\n      );\n    }\n    else {\n      // This is a tuple\n      const checks = types.map(\n        (type, index) => checkAnnotation(\n          t.memberExpression(\n            input,\n            t.numericLiteral(index),\n            true\n          ),\n          type,\n          scope\n        )\n      ).filter(identity);\n\n      const checkLength = t.binaryExpression(\n        '>=',\n        t.memberExpression(\n          input,\n          t.identifier('length')\n        ),\n        t.numericLiteral(types.length)\n      );\n\n      return checks.reduce((last, check, index) => {\n        return t.logicalExpression(\n          \"&&\",\n          last,\n          check\n        );\n      }, t.logicalExpression(\n        '&&',\n        checkIsArray({input}),\n        checkLength\n      ));\n    }\n  }\n\n  function checkTuple ({input, types, scope}): Node {\n    if (types.length === 0) {\n      return checkIsArray({input});\n    }\n\n    // This is a tuple\n    const checks = types.map(\n      (type, index) => checkAnnotation(\n        t.memberExpression(\n          input,\n          t.numericLiteral(index),\n          true\n        ),\n        type,\n        scope\n      )\n    ).filter(identity);\n\n    const checkLength = t.binaryExpression(\n      '>=',\n      t.memberExpression(\n        input,\n        t.identifier('length')\n      ),\n      t.numericLiteral(types.length)\n    );\n\n    return checks.reduce((last, check, index) => {\n      return t.logicalExpression(\n        \"&&\",\n        last,\n        check\n      );\n    }, t.logicalExpression(\n      '&&',\n      checkIsArray({input}),\n      checkLength\n    ));\n  }\n\n  function checkObject ({input, properties, indexers, scope}): Node {\n    if (input.type === 'ObjectPattern') {\n      return checkObjectPattern({input, properties, scope});\n    }\n    const propNames = [];\n    const check = properties.length === 0 ? checkIsObject({input}) : properties.reduce((expr, prop, index) => {\n      const target = prop.key.type === 'Identifier' ? t.memberExpression(input, prop.key) : t.memberExpression(input, prop.key, true);\n      propNames.push(prop.key.type === 'Identifier' ? t.stringLiteral(prop.key.name) : prop.key);\n      let check = checkAnnotation(target, prop.value, scope);\n      if (check) {\n        if (prop.optional) {\n          check = t.logicalExpression(\n            '||',\n            checks.undefined({input: target}),\n            check\n          );\n        }\n        return t.logicalExpression(\n          \"&&\",\n          expr,\n          check\n        );\n      }\n      else {\n        return expr;\n      }\n    }, checkNotNull({input}));\n\n    if (indexers.length) {\n      return indexers.reduceRight((expr, indexer) => {\n        if (indexer.value.type === 'AnyTypeAnnotation') {\n          return expr;\n        }\n        const value = scope.generateUidIdentifier(indexer.id.name);\n        let check = checkAnnotation(value, indexer.value, scope);\n        const fixedKeys = t.arrayExpression(propNames);\n\n        if (check) {\n          if (propNames.length) {\n            return t.logicalExpression('&&', expr, checkObjectIndexers({input, value, check, fixedKeys}));\n          }\n          else {\n            return t.logicalExpression('&&', expr, checkObjectIndexersNoFixed({input, value, check, fixedKeys}));\n          }\n        }\n        else {\n          return expr;\n        }\n      }, check);\n    }\n\n    return check;\n  }\n\n  function checkObjectPattern ({input, properties, scope}): ?Node {\n    const propNames = properties.reduce((names, prop) => {\n      names[prop.key.name] = prop;\n      return names;\n    }, {});\n    const propChecks = {};\n    for (let item of input.properties) {\n      let {key, value: id} = item;\n      let prop = propNames[key.name];\n      if (!prop) {\n        continue;\n      }\n      const check = checkAnnotation(id, prop.value, scope);\n      if (check) {\n        propChecks[key.name] = check;\n      }\n    }\n    return Object.keys(propChecks).reduce((last, name) => {\n      const check = propChecks[name];\n      if (last === null) {\n        return check;\n      }\n      else {\n        return t.logicalExpression('&&', last, check);\n      }\n    }, null);\n  }\n\n  function createTypeAliasChecks (path: NodePath): Node {\n    const {node, scope} = path;\n    const {id, right: annotation} = node;\n    const input = t.identifier('input');\n    const check = checkAnnotation(input, annotation, scope) || t.booleanLiteral(true);\n    const declaration = declareTypeChecker({id, check});\n    declaration.isTypeChecker = true;\n    declaration.savedTypeAnnotation = annotation;\n    declaration.declarations[0].savedTypeAnnotation = annotation;\n    return declaration;\n  }\n\n\n  function createInterfaceChecks (path: NodePath): Node {\n    const {node, scope} = path;\n    const {id, body: annotation} = node;\n    const input = t.identifier('input');\n    const check = node.extends.reduce(\n      (check, extender) => {\n        return t.logicalExpression(\n          '&&',\n          check,\n          checkAnnotation(input, t.genericTypeAnnotation(extender.id), path.scope)\n        );\n        return check;\n      },\n      checkAnnotation(input, annotation, scope) || t.booleanLiteral(true)\n    );\n\n    const declaration = declareTypeChecker({id, check});\n    declaration.isTypeChecker = true;\n    return declaration;\n  }\n\n  function checkAnnotation (input: Node, annotation: TypeAnnotation, scope: Scope): ?Node {\n    switch (annotation.type) {\n      case 'TypeAnnotation':\n      case 'FunctionTypeParam':\n        return checkAnnotation(input, annotation.typeAnnotation, scope);\n      case 'TypeofTypeAnnotation':\n        return checks.typeof({input, annotation: annotation.argument, scope});\n      case 'GenericTypeAnnotation':\n        if (annotation.id.name === 'Array') {\n          return checks.array({input, types: annotation.typeParameters ? annotation.typeParameters.params : [], scope});\n        }\n        else if (annotation.id.name === 'Generator' && !scope.hasBinding('Generator')) {\n          return checks.generator({input, types: annotation.typeParameters ? annotation.typeParameters.params : [], scope});\n        }\n        else if (annotation.id.name === 'Iterable' && !scope.hasBinding('Iterable')) {\n          return checks.iterable({input, types: annotation.typeParameters ? annotation.typeParameters.params : [], scope});\n        }\n        else if (annotation.id.name === 'Map' && !scope.getBinding('Map')) {\n          return checks.map({input, types: annotation.typeParameters ? annotation.typeParameters.params : [], scope});\n        }\n        else if (annotation.id.name === 'Set' && !scope.getBinding('Set')) {\n          return checks.set({input, types: annotation.typeParameters ? annotation.typeParameters.params : [], scope});\n        }\n        else if (annotation.id.name === 'Function') {\n          return checks.function({input});\n        }\n        else if (annotation.id.name === 'Class' && !scope.hasBinding('Class')) {\n          return checks.class({input, types: annotation.typeParameters ? annotation.typeParameters.params : [], scope});\n        }\n        else if (annotation.id.name === 'int8' && !scope.hasBinding('int8')) {\n          return checks.int8({input});\n        }\n        else if (annotation.id.name === 'uint8' && !scope.hasBinding('uint8')) {\n          return checks.uint8({input});\n        }\n        else if (annotation.id.name === 'int16' && !scope.hasBinding('int16')) {\n          return checks.int16({input});\n        }\n        else if (annotation.id.name === 'uint16' && !scope.hasBinding('uint16')) {\n          return checks.uint16({input});\n        }\n        else if (annotation.id.name === 'int32' && !scope.hasBinding('int32')) {\n          return checks.int32({input});\n        }\n        else if (annotation.id.name === 'uint32' && !scope.hasBinding('uint32')) {\n          return checks.uint32({input});\n        }\n        else if (annotation.id.name === 'float32' && !scope.hasBinding('float32')) {\n          return checks.float32({input});\n        }\n        else if (annotation.id.name === 'float64' && !scope.hasBinding('float64')) {\n          return checks.float64({input});\n        }\n        else if (annotation.id.name === 'double' && !scope.hasBinding('double')) {\n          return checks.double({input});\n        }\n        else if (annotation.id.name === 'Symbol' && !scope.getBinding('Symbol')) {\n          return checks.symbol({input});\n        }\n        else if (isTypeChecker(annotation.id, scope)) {\n          return checks.type({input, type: annotation.id});\n        }\n        else if (isPolymorphicType(annotation.id, scope)) {\n          return;\n        }\n        else {\n          return checks.instanceof({input, type: createTypeExpression(annotation.id)});\n        }\n      case 'TupleTypeAnnotation':\n        return checks.tuple({input, types: annotation.types, scope});\n      case 'NumberTypeAnnotation':\n        return checks.number({input});\n      case 'NumericLiteralTypeAnnotation':\n        return checks.numericLiteral({input, annotation});\n      case 'BooleanTypeAnnotation':\n        return checks.boolean({input});\n      case 'BooleanLiteralTypeAnnotation':\n        return checks.booleanLiteral({input, annotation});\n      case 'StringTypeAnnotation':\n        return checks.string({input});\n      case 'StringLiteralTypeAnnotation':\n        return checks.stringLiteral({input, annotation});\n      case 'UnionTypeAnnotation':\n        return checks.union({input, types: annotation.types, scope});\n      case 'IntersectionTypeAnnotation':\n        return checks.intersection({input, types: annotation.types, scope});\n      case 'ObjectTypeAnnotation':\n        return checks.object({input, properties: annotation.properties || [], indexers: annotation.indexers, scope});\n      case 'ArrayTypeAnnotation':\n        return checks.array({input, types: [annotation.elementType || t.anyTypeAnnotation()], scope});\n      case 'FunctionTypeAnnotation':\n        return checks.function({input, params: annotation.params, returnType: annotation.returnType});\n      case 'MixedTypeAnnotation':\n        return checks.mixed({input});\n      case 'AnyTypeAnnotation':\n      case 'ExistentialTypeParam':\n        return checks.any({input});\n      case 'NullableTypeAnnotation':\n        return checks.nullable({input, type: annotation.typeAnnotation, scope});\n      case 'VoidTypeAnnotation':\n      case 'NullLiteralTypeAnnotation':\n        return checks.void({input});\n    }\n  }\n\n  function staticCheckAnnotation (path: NodePath, annotation: TypeAnnotation): ?boolean {\n    const other = getAnnotation(path);\n    switch (annotation.type) {\n      case 'TypeAnnotation':\n      case 'FunctionTypeParam':\n        return staticCheckAnnotation(path, annotation.typeAnnotation);\n      case 'GenericTypeAnnotation':\n        if (isTypeChecker(annotation.id, path.scope)) {\n          return staticChecks.type({path, type: annotation.id});\n        }\n        else if (isPolymorphicType(annotation.id, path.scope)) {\n          return;\n        }\n        else if (annotation.id.name === 'Symbol') {\n          return staticChecks.symbol(path);\n        }\n        else {\n          return staticChecks.instanceof({path, annotation});\n        }\n    }\n    return compareAnnotations(annotation, other);\n  }\n\n  /**\n   * Get the type annotation for a given node.\n   */\n  function getAnnotation (path: NodePath): TypeAnnotation {\n    let annotation;\n    try {\n      annotation = getAnnotationShallow(path);\n    }\n    catch (e) {\n      if (e instanceof SyntaxError) {\n        throw e;\n      }\n      if (process.env.TYPECHECK_DEBUG) {\n        console.error(e.stack);\n      }\n    }\n    while (annotation && annotation.type === 'TypeAnnotation') {\n      annotation = annotation.typeAnnotation;\n    }\n    return annotation || t.anyTypeAnnotation();\n  }\n\n  function getAnnotationShallow (path: NodePath): ?TypeAnnotation {\n    if (!path || !path.node) {\n      return t.voidTypeAnnotation();\n    }\n    const {node, scope} = path;\n    if (node.type === 'TypeAlias') {\n      return node.right;\n    }\n    else if (node.type === 'ClassProperty' && node.typeAnnotation) {\n      return getClassPropertyAnnotation(path);\n    }\n    else if (node.type === 'ClassMethod' && node.returnType) {\n      return getClassMethodAnnotation(path);\n    }\n    else if (node.type === 'ObjectProperty' && node.typeAnnotation) {\n      return getObjectPropertyAnnotation(path);\n    }\n    else if (node.type === 'SpreadProperty' && node.typeAnnotation) {\n      return getSpreadPropertyAnnotation(path);\n    }\n    else if (node.type === 'ObjectMethod' && node.returnType) {\n      return getObjectMethodAnnotation(path);\n    }\n    else if (!node.typeAnnotation && !node.savedTypeAnnotation && !node.returnType) {\n      switch (path.type) {\n        case 'Identifier':\n          const binding = scope.getBinding(node.name);\n          if (!binding || !binding.identifier) {\n            return path.getTypeAnnotation();\n          }\n          const id = binding.identifier;\n          if (binding.path.type === 'ObjectPattern') {\n            return getObjectPatternAnnotation(binding.path, node.name);\n          }\n          if (id.savedTypeAnnotation) {\n            return id.savedTypeAnnotation;\n          }\n          else if (id.returnType) {\n            return id.returnType;\n          }\n          else if (id.typeAnnotation) {\n            return id.typeAnnotation;\n          }\n          else if (isPolymorphicType(id, scope)) {\n            return t.anyTypeAnnotation();\n          }\n          return binding.constant ? binding.path.getTypeAnnotation() : path.getTypeAnnotation();\n        case 'StringLiteral':\n        case 'NumericLiteral':\n        case 'BooleanLiteral':\n          return createLiteralTypeAnnotation(path);\n        case 'CallExpression':\n          const callee = path.get('callee');\n          if (callee.type === 'Identifier') {\n            if (callee.name === 'Symbol') {\n              return t.genericTypeAnnotation('Symbol');\n            }\n            const fn = getFunctionForIdentifier(callee);\n            if (fn) {\n              return getAnnotation(fn);\n            }\n          }\n          break;\n        case 'ThisExpression':\n          return getThisExpressionAnnotation(path);\n        case 'AssignmentExpression':\n          return getAssignmentExpressionAnnotation(path);\n        case 'MemberExpression':\n          return getMemberExpressionAnnotation(path);\n        case 'ArrayExpression':\n          return getArrayExpressionAnnotation(path);\n        case 'ObjectExpression':\n          return getObjectExpressionAnnotation(path);\n        case 'BinaryExpression':\n          return getBinaryExpressionAnnotation(path);\n        case 'LogicalExpression':\n          return getLogicalExpressionAnnotation(path);\n        case 'ConditionalExpression':\n          return getConditionalExpressionAnnotation(path);\n        case 'ObjectMethod':\n          return getObjectMethodAnnotation(path);\n        case 'SpreadProperty':\n          return getSpreadPropertyAnnotation(path);\n        case 'ObjectProperty':\n          return getObjectPropertyAnnotation(path);\n        case 'ClassDeclaration':\n          return getClassDeclarationAnnotation(path);\n        case 'ClassMethod':\n          return getClassMethodAnnotation(path);\n        case 'ClassProperty':\n          return getClassPropertyAnnotation(path);\n        default:\n          return path.getTypeAnnotation();\n\n      }\n    }\n    return node.savedTypeAnnotation || node.returnType || node.typeAnnotation || path.getTypeAnnotation();\n  }\n\n  function createLiteralTypeAnnotation (path: NodePath): ?TypeAnnotation {\n    let annotation;\n    if (path.isStringLiteral()) {\n      annotation = t.stringLiteralTypeAnnotation();\n    }\n    else if (path.isNumericLiteral()) {\n      annotation = t.numericLiteralTypeAnnotation();\n    }\n    else if (path.isBooleanLiteral()) {\n      annotation = t.booleanLiteralTypeAnnotation();\n    }\n    else {\n      return path.getTypeAnnotation();\n    }\n    annotation.value = path.node.value;\n    return annotation;\n  }\n\n  function getObjectPatternAnnotation (path: NodePath, name: string): ?TypeAnnotation {\n    let annotation = keyByName(getAnnotation(path), name);\n    let found;\n    if (!path.node.properties) {\n      return;\n    }\n    for (let prop of path.get('properties')) {\n      if (prop.node.value && prop.node.value.name === name) {\n        found = prop.get('key');\n        break;\n      }\n      else if (prop.node.key.type === 'Identifier' && prop.node.key.name === name) {\n        found = prop.get('key');\n        break;\n      }\n    }\n    if (!annotation || !found) {\n      return;\n    }\n    if (found.type === 'Identifier') {\n      annotation.value.authoritative = false;\n      return annotation.value;\n    }\n  }\n\n\n  function keyByName (node: Node, name: string): ?Node {\n    if (!node.properties) {\n      return;\n    }\n    for (let prop of node.properties) {\n      if (prop.key && prop.key.name === name) {\n        return prop;\n      }\n    }\n  }\n\n  function valueByName (node: Node, name: string): ?Node {\n    if (!node.properties) {\n      return;\n    }\n    for (let prop of node.properties) {\n      if (prop.value && prop.value.name === name) {\n        return prop;\n      }\n    }\n  }\n\n  function getSpreadPropertyAnnotation (path: NodePath): ?TypeAnnotation {\n    const {node} = path;\n    let annotation = node.typeAnnotation || node.savedTypeAnnotation;\n    if (!annotation) {\n      annotation = getAnnotation(path.get('argument'));\n    }\n    return annotation;\n  }\n\n  function getObjectPropertyAnnotation (path: NodePath): ?TypeAnnotation {\n    const {node} = path;\n    let annotation = node.typeAnnotation || node.savedTypeAnnotation;\n    if (!annotation) {\n      if (node.value) {\n        if(node.value.typeAnnotation || node.value.savedTypeAnnotation) {\n          annotation = node.value.typeAnnotation || node.value.savedTypeAnnotation;\n        }\n        else if (node.value.type === 'BooleanLiteral' || node.value.type === 'NumericLiteral' || node.value.type === 'StringLiteral') {\n          annotation = t[node.value.type](node.value.value)\n        }\n        else {\n          annotation = t.anyTypeAnnotation()\n        }\n      }\n      else {\n        annotation = t.anyTypeAnnotation();\n      }\n    }\n    return t.objectTypeProperty(\n      node.key,\n      annotation\n    );\n  }\n\n  function getObjectMethodAnnotation (path: NodePath): ?TypeAnnotation {\n    const {node} = path;\n    return t.objectTypeProperty(\n      t.identifier(node.key.name),\n      t.functionTypeAnnotation(\n        null,\n        node.params.map(param => param.savedTypeAnnotation || param.typeAnnotation),\n        null,\n        node.savedTypeAnnotation || node.returnType || node.typeAnnotation || t.anyTypeAnnotation()\n      )\n    );\n  }\n\n  function getThisExpressionAnnotation (path: NodePath): ?TypeAnnotation {\n    let parent = path.parentPath;\n    loop: while (parent) {\n      switch (parent.type) {\n        case 'ClassDeclaration':\n          return getAnnotation(parent);\n        case 'ClassBody':\n          return getAnnotation(parent.parentPath);\n        case 'ClassMethod':\n        case 'ClassProperty':\n          return getAnnotation(parent.parentPath.parentPath);\n        case 'ObjectProperty':\n          return getAnnotation(parent.parentPath);\n        case 'ObjectMethod':\n          return getAnnotation(parent.parentPath);\n        case 'FunctionExpression':\n          if (parent.parentPath.type === 'ObjectProperty') {\n            return getAnnotation(parent.parentPath.parentPath);\n          }\n          break loop;\n        case 'ArrowFunctionExpression':\n          parent = parent.parentPath;\n          continue;\n      }\n      if (parent.isFunction()) {\n        break;\n      }\n      parent = parent.parentPath;\n    }\n    return t.objectTypeAnnotation([]);\n  }\n\n  function getClassDeclarationAnnotation (path: NodePath): ?TypeAnnotation {\n    const body = path.get('body').get('body').map(getAnnotation).filter(annotation => annotation && annotation.type !== 'AnyTypeAnnotation');\n    return t.objectTypeAnnotation(body);\n  }\n\n  function getAssignmentExpressionAnnotation (path: NodePath): ?TypeAnnotation {\n    if (path.node.operator === '=') {\n      return getAnnotation(path.get('right'));\n    }\n  }\n\n  function getClassPropertyAnnotation (path: NodePath): ?TypeAnnotation {\n    const {node} = path;\n    if (node.computed) {\n      return;\n    }\n    const annotation = node.typeAnnotation || (node.value ? node.value.savedTypeAnnotation || node.value.typeAnnotation : t.anyTypeAnnotation());\n    return t.objectTypeProperty(\n      node.key,\n      annotation || t.anyTypeAnnotation()\n    );\n  }\n\n  function getClassMethodAnnotation (path: NodePath): ?TypeAnnotation {\n    const {node} = path;\n    if (node.computed) {\n      return;\n    }\n    if (node.kind === 'get') {\n      return t.objectTypeProperty(\n        node.key,\n        node.savedTypeAnnotation || node.returnType || node.typeAnnotation || t.anyTypeAnnotation()\n      );\n    }\n    else if (node.kind === 'set') {\n      return t.objectTypeProperty(\n        node.key,\n        node.params.map(param => param.savedTypeAnnotation || param.typeAnnotation).shift() || t.anyTypeAnnotation()\n      );\n    }\n    else {\n      return t.objectTypeProperty(\n        node.key,\n        t.functionTypeAnnotation(\n          null,\n          node.params.map(param => param.savedTypeAnnotation || param.typeAnnotation || t.anyTypeAnnotation()),\n          null,\n          node.savedTypeAnnotation || node.returnType || node.typeAnnotation || t.anyTypeAnnotation()\n        )\n      );\n    }\n  }\n\n  function getBinaryExpressionAnnotation (path: NodePath): TypeAnnotation {\n    const {node} = path;\n    if (isBooleanExpression(node)) {\n      return t.booleanTypeAnnotation();\n    }\n    else {\n      return t.anyTypeAnnotation();\n    }\n  }\n\n  function getLogicalExpressionAnnotation (path: NodePath): TypeAnnotation {\n    const {node} = path;\n    if (isBooleanExpression(node)) {\n      return t.booleanTypeAnnotation();\n    }\n    else {\n      let left = path.get('left');\n      let right = path.get('right');\n      switch (node.operator) {\n        case '&&':\n        case '||':\n          ([left, right] = [getAnnotation(left), getAnnotation(right)]);\n          if (t.isUnionTypeAnnotation(left)) {\n            if (t.isUnionTypeAnnotation(right)) {\n              return t.unionTypeAnnotation(left.types.concat(right.types));\n            }\n            else {\n              return t.unionTypeAnnotation(left.types.concat(right));\n            }\n          }\n          else {\n            return t.unionTypeAnnotation([left, right]);\n          }\n      }\n      return t.anyTypeAnnotation();\n    }\n  }\n\n\n  function getConditionalExpressionAnnotation (path: NodePath): TypeAnnotation {\n    const {node} = path;\n    const consequent = getAnnotation(path.get('consequent'));\n    const alternate = getAnnotation(path.get('alternate'));\n    if (t.isUnionTypeAnnotation(consequent)) {\n      if (t.isUnionTypeAnnotation(alternate)) {\n        return t.unionTypeAnnotation(consequent.types.concat(alternate.types));\n      }\n      else {\n        return t.unionTypeAnnotation(consequent.types.concat(alternate));\n      }\n    }\n    else {\n      return t.unionTypeAnnotation([consequent, alternate]);\n    }\n  }\n\n  function getArrayExpressionAnnotation (path: NodePath): TypeAnnotation {\n    return t.genericTypeAnnotation(\n      t.identifier('Array'),\n      t.typeParameterDeclaration(path.get('elements').map(getAnnotation))\n    );\n  }\n\n  function getObjectExpressionAnnotation (path: NodePath): TypeAnnotation {\n    const annotation = t.objectTypeAnnotation(\n      path.get('properties')\n      .filter(prop => !prop.node.computed)\n      .map(getAnnotation)\n      .reduce((properties, prop) => {\n        if (t.isObjectTypeProperty(prop)) {\n          properties.push(prop);\n        }\n        else if (t.isObjectTypeAnnotation(prop)) {\n          properties.push(...prop.properties);\n        }\n        return properties;\n      }, [])\n      .filter(annotation => !t.isAnyTypeAnnotation(annotation.value))\n    );\n    return annotation;\n  }\n\n  function getMemberExpressionAnnotation (path: NodePath): TypeAnnotation {\n    if (path.node.computed) {\n      return getComputedMemberExpressionAnnotation(path);\n    }\n    const stack = [];\n    let target = path;\n    while (target.isMemberExpression()) {\n      stack.push(target);\n      if (target.node.computed) {\n        break;\n      }\n      target = target.get('object');\n    }\n    const objectAnnotation = stack.reduceRight((last, target) => {\n      let annotation = last;\n      if (annotation == null) {\n        if (stack.length === 1) {\n          annotation = getAnnotation(target.get('object'));\n        }\n        else {\n          return getAnnotation(target);\n        }\n      }\n\n      switch (annotation.type) {\n        case 'AnyTypeAnnotation':\n          return annotation;\n        case 'NullableTypeAnnotation':\n        case 'TypeAnnotation':\n          annotation = annotation.typeAnnotation;\n      }\n\n      if (annotation.type === 'GenericTypeAnnotation') {\n        const typeChecker = getTypeChecker(annotation.id, path.scope);\n        if (typeChecker) {\n          annotation = getAnnotation(typeChecker);\n        }\n        else {\n          const binding = path.scope.getBinding(annotation.id.name);\n          if (binding) {\n            annotation = getAnnotation(binding.path);\n          }\n        }\n      }\n      switch (annotation.type) {\n        case 'AnyTypeAnnotation':\n          return annotation;\n        case 'ObjectTypeAnnotation':\n          const id = target.get('property').node;\n          for (let {key, value} of annotation.properties || []) {\n            if (key.name === id.name) {\n              return (value.type === 'VoidTypeAnnotation' || value.type === 'NullLiteralTypeAnnotation') ? t.anyTypeAnnotation() : value;\n            }\n          }\n      }\n      return t.anyTypeAnnotation();\n    }, null);\n\n    return objectAnnotation || path.getTypeAnnotation();\n  }\n\n  function getComputedMemberExpressionAnnotation (path: NodePath): TypeAnnotation {\n    const object = path.get('object');\n    const property = path.get('property');\n    let objectAnnotation = getAnnotation(object);\n    if (objectAnnotation.type === 'TypeAnnotation' || objectAnnotation.type === 'NullableTypeAnnotation') {\n      objectAnnotation = objectAnnotation.typeAnnotation;\n    }\n    let propertyAnnotation = getAnnotation(property);\n    if (propertyAnnotation.type === 'TypeAnnotation' || propertyAnnotation.type === 'NullableTypeAnnotation') {\n      propertyAnnotation = propertyAnnotation.typeAnnotation;\n    }\n    const {confident, value} = property.evaluate();\n    if (!confident) {\n      return path.getTypeAnnotation();\n    }\n    switch (objectAnnotation.type) {\n      case 'TupleTypeAnnotation':\n        if (objectAnnotation.types.length === 0) {\n          break;\n        }\n        else if (typeof value === 'number') {\n          if (!objectAnnotation.types[value]) {\n            throw path.buildCodeFrameError(`Invalid computed member expression for tuple: ` + humanReadableType(objectAnnotation));\n          }\n          return objectAnnotation.types[value];\n        }\n        else {\n          throw path.buildCodeFrameError(`Invalid computed member expression for tuple: ` + humanReadableType(objectAnnotation));\n        }\n        break;\n    }\n    return path.getTypeAnnotation();\n  }\n\n  function getFunctionForIdentifier (path: NodePath): boolean|Node {\n    if (path.type !== 'Identifier') {\n      return false;\n    }\n    const ref = path.scope.getBinding(path.node.name);\n    if (!ref) {\n      return false;\n    }\n    return t.isFunction(ref.path.parent) && ref.path.parentPath;\n  }\n\n  /**\n   * Determine whether the given annotation is for an array.\n   */\n  function isStrictlyArrayAnnotation (annotation: TypeAnnotation): ?boolean {\n    switch (annotation.type) {\n      case 'ArrayTypeAnnotation':\n      case 'TupleTypeAnnotation':\n        return true;\n      case 'TypeAnnotation':\n      case 'FunctionTypeParam':\n        return isStrictlyArrayAnnotation(annotation.typeAnnotation);\n      case 'GenericTypeAnnotation':\n        return annotation.id.name === 'Array' ? true : null;\n      case 'UnionTypeAnnotation':\n        return annotation.types.every(isStrictlyArrayAnnotation);\n      default:\n        return false;\n    }\n  }\n\n  function compareMaybeUnion (annotation: TypeAnnotation, comparator: (node: TypeAnnotation) => ?boolean): ?boolean {\n    let falseCount = 0;\n    for (let type of annotation.types) {\n      const result = comparator(type);\n      if (result === true) {\n        return true;\n      }\n      else if (result === false) {\n        falseCount++;\n      }\n    }\n    if (falseCount === annotation.types.length) {\n      return false;\n    }\n    else {\n      return null;\n    }\n  }\n\n  /**\n   * Returns `true` if the annotation is compatible with a number,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */\n  function maybeNumberAnnotation (annotation: TypeAnnotation): ?boolean {\n    switch (annotation.type) {\n      case 'TypeAnnotation':\n      case 'FunctionTypeParam':\n      case 'NullableTypeAnnotation':\n        return maybeNumberAnnotation(annotation.typeAnnotation);\n      case 'NumberTypeAnnotation':\n      case 'NumericLiteralTypeAnnotation':\n      case 'NumericLiteral':\n        return true;\n      case 'GenericTypeAnnotation':\n        switch (annotation.id.name) {\n          case 'Array':\n          case 'Function':\n          case 'Object':\n          case 'String':\n          case 'Boolean':\n          case 'Date':\n          case 'RegExp':\n            return false;\n          default:\n            return null;\n        }\n      case 'UnionTypeAnnotation':\n        return compareMaybeUnion(annotation, maybeNumberAnnotation);\n      case 'AnyTypeAnnotation':\n      case 'MixedTypeAnnotation':\n      case 'IntersectionTypeAnnotation':\n        return null;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Returns `true` if the annotation is compatible with a string,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */\n  function maybeStringAnnotation (annotation: TypeAnnotation): ?boolean {\n    switch (annotation.type) {\n      case 'TypeAnnotation':\n      case 'FunctionTypeParam':\n      case 'NullableTypeAnnotation':\n        return maybeStringAnnotation(annotation.typeAnnotation);\n      case 'StringTypeAnnotation':\n      case 'StringLiteral':\n        return true;\n      case 'StringLiteralTypeAnnotation':\n        return null;\n      case 'GenericTypeAnnotation':\n        switch (annotation.id.name) {\n          case 'Array':\n          case 'Function':\n          case 'Object':\n          case 'Number':\n          case 'Boolean':\n          case 'Date':\n          case 'RegExp':\n            return false;\n          default:\n            return null;\n        }\n      case 'UnionTypeAnnotation':\n        let falseCount = 0;\n        for (let type of annotation.types) {\n          const result = maybeStringAnnotation(type);\n          if (result === true) {\n            return true;\n          }\n          else if (result === false) {\n            falseCount++;\n          }\n        }\n        if (falseCount === annotation.types.length) {\n          return false;\n        }\n        else {\n          return null;\n        }\n      case 'AnyTypeAnnotation':\n      case 'MixedTypeAnnotation':\n      case 'IntersectionTypeAnnotation':\n        return null;\n      default:\n        return false;\n    }\n  }\n\n/**\n   * Returns `true` if the annotation is compatible with a symbol,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */\n  function maybeSymbolAnnotation (annotation: TypeAnnotation): ?boolean {\n    switch (annotation.type) {\n      case 'TypeAnnotation':\n      case 'FunctionTypeParam':\n      case 'NullableTypeAnnotation':\n        return maybeSymbolAnnotation(annotation.typeAnnotation);\n      case 'GenericTypeAnnotation':\n        switch (annotation.id.name) {\n          case 'Array':\n          case 'Function':\n          case 'Object':\n          case 'Number':\n          case 'Boolean':\n          case 'Date':\n          case 'RegExp':\n            return false;\n          case 'Symbol':\n            return true;\n          default:\n            return null;\n        }\n      case 'UnionTypeAnnotation':\n        let falseCount = 0;\n        for (let type of annotation.types) {\n          const result = maybeSymbolAnnotation(type);\n          if (result === true) {\n            return true;\n          }\n          else if (result === false) {\n            falseCount++;\n          }\n        }\n        if (falseCount === annotation.types.length) {\n          return false;\n        }\n        else {\n          return null;\n        }\n      case 'AnyTypeAnnotation':\n      case 'MixedTypeAnnotation':\n      case 'IntersectionTypeAnnotation':\n        return null;\n      default:\n        return false;\n    }\n  }\n\n\n  /**\n   * Returns `true` if the annotation is compatible with a boolean,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */\n  function maybeBooleanAnnotation (annotation: TypeAnnotation): ?boolean {\n    switch (annotation.type) {\n      case 'TypeAnnotation':\n      case 'FunctionTypeParam':\n      case 'NullableTypeAnnotation':\n        return maybeBooleanAnnotation(annotation.typeAnnotation);\n      case 'BooleanTypeAnnotation':\n      case 'BooleanLiteralTypeAnnotation':\n      case 'BooleanLiteral':\n        return true;\n      case 'GenericTypeAnnotation':\n        switch (annotation.id.name) {\n          case 'Array':\n          case 'Function':\n          case 'Object':\n          case 'String':\n          case 'Number':\n          case 'Date':\n          case 'RegExp':\n            return false;\n          default:\n            return null;\n        }\n      case 'UnionTypeAnnotation':\n        let falseCount = 0;\n        for (let type of annotation.types) {\n          const result = maybeBooleanAnnotation(type);\n          if (result === true) {\n            return true;\n          }\n          else if (result === false) {\n            falseCount++;\n          }\n        }\n        if (falseCount === annotation.types.length) {\n          return false;\n        }\n        else {\n          return null;\n        }\n      case 'AnyTypeAnnotation':\n      case 'MixedTypeAnnotation':\n      case 'IntersectionTypeAnnotation':\n        return null;\n      default:\n        return false;\n    }\n  }\n\n\n  /**\n   * Returns `true` if the annotation is compatible with a function,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */\n  function maybeFunctionAnnotation (annotation: TypeAnnotation): ?boolean {\n    switch (annotation.type) {\n      case 'TypeAnnotation':\n      case 'FunctionTypeParam':\n      case 'NullableTypeAnnotation':\n        return maybeFunctionAnnotation(annotation.typeAnnotation);\n      case 'FunctionTypeAnnotation':\n        return true;\n      case 'GenericTypeAnnotation':\n        switch (annotation.id.name) {\n          case 'Array':\n          case 'Number':\n          case 'Object':\n          case 'String':\n          case 'Boolean':\n          case 'Date':\n          case 'RegExp':\n            return false;\n          default:\n            return null;\n        }\n      case 'UnionTypeAnnotation':\n        let falseCount = 0;\n        for (let type of annotation.types) {\n          const result = maybeFunctionAnnotation(type);\n          if (result === true) {\n            return true;\n          }\n          else if (result === false) {\n            falseCount++;\n          }\n        }\n        if (falseCount === annotation.types.length) {\n          return false;\n        }\n        else {\n          return null;\n        }\n      case 'AnyTypeAnnotation':\n      case 'MixedTypeAnnotation':\n      case 'IntersectionTypeAnnotation':\n        return null;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Returns `true` if the annotation is compatible with an undefined or null type,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */\n  function maybeNullableAnnotation (annotation: TypeAnnotation): ?boolean {\n    switch (annotation.type) {\n      case 'NullableTypeAnnotation':\n      case 'VoidTypeAnnotation':\n      case 'NullLiteralTypeAnnotation':\n      case 'MixedTypeAnnotation':\n        return true;\n      case 'TypeAnnotation':\n      case 'FunctionTypeParam':\n        return maybeNullableAnnotation(annotation.typeAnnotation);\n      case 'GenericTypeAnnotation':\n        switch (annotation.id.name) {\n          case 'Array':\n          case 'Number':\n          case 'Object':\n          case 'String':\n          case 'Boolean':\n          case 'Date':\n          case 'RegExp':\n            return false;\n          case 'Generator':\n            if (annotation.typeParameters && annotation.typeParameters.params.length > 1) {\n              return maybeNullableAnnotation(annotation.typeParameters.params[1]);\n            }\n            else {\n              return null;\n            }\n          default:\n            return null;\n        }\n      case 'UnionTypeAnnotation':\n        let falseCount = 0;\n        for (let type of annotation.types) {\n          const result = maybeNullableAnnotation(type);\n          if (result === true) {\n            return true;\n          }\n          else if (result === false) {\n            falseCount++;\n          }\n        }\n        if (falseCount === annotation.types.length) {\n          return false;\n        }\n        else {\n          return null;\n        }\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Returns `true` if the annotation is compatible with an object type,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */\n  function maybeInstanceOfAnnotation (annotation: TypeAnnotation, expected: Identifier, typeParameters: TypeAnnotation[]): ?boolean {\n    switch (annotation.type) {\n      case 'TypeAnnotation':\n      case 'FunctionTypeParam':\n      case 'NullableTypeAnnotation':\n        return maybeInstanceOfAnnotation(annotation.typeAnnotation, expected, typeParameters);\n      case 'GenericTypeAnnotation':\n        if (annotation.id.name === expected.name) {\n          if (typeParameters.length === 0) {\n            return true;\n          }\n          if (annotation.typeParameters && annotation.typeParameters.params.length) {\n            let trueCount = 0;\n            let nullCount = 0;\n            for (let i = 0; i < typeParameters.length && i < annotation.typeParameters.params.length; i++) {\n              const result = compareAnnotations(typeParameters[i], annotation.typeParameters.params[i]);\n              if (result === false) {\n                return false;\n              }\n              else if (result === true) {\n                trueCount++;\n              }\n              else {\n                nullCount++;\n              }\n            }\n            return trueCount > 0 && nullCount === 0 ? true : null;\n          }\n        }\n        return null;\n      case 'UnionTypeAnnotation':\n        let falseCount = 0;\n        for (let type of annotation.types) {\n          const result = maybeInstanceOfAnnotation(type, expected, typeParameters);\n          if (result === true) {\n            return true;\n          }\n          else if (result === false) {\n            falseCount++;\n          }\n        }\n        if (falseCount === annotation.types.length) {\n          return false;\n        }\n        else {\n          return null;\n        }\n      case 'VoidTypeAnnotation':\n      case 'NullLiteralTypeAnnotation':\n        if (expected.name === 'Array' || expected.name === 'RegExp' || expected.name === 'Error' || expected.name === 'Function' || expected.name === 'String' || expected.name === 'Object') {\n          return false;\n        }\n        else {\n          return null;\n        }\n      case 'BooleanTypeAnnotation':\n      case 'BooleanLiteralTypeAnnotation':\n      case 'StringTypeAnnotation':\n      case 'StringLiteralTypeAnnotation':\n      case 'NumberTypeAnnotation':\n      case 'NumericLiteralTypeAnnotation':\n        if (expected.name === 'Array' || expected.name === 'RegExp' || expected.name === 'Error' || expected.name === 'Function') {\n          return false;\n        }\n        else {\n          return null;\n        }\n      case 'FunctionTypeAnnotation':\n        if (expected.name === 'Function') {\n          return true;\n        }\n        else {\n          return null;\n        }\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * Returns `true` if the annotation is compatible with an array,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */\n  function maybeArrayAnnotation (annotation: TypeAnnotation): ?boolean {\n    switch (annotation.type) {\n      case 'TypeAnnotation':\n      case 'FunctionTypeParam':\n      case 'NullableTypeAnnotation':\n        return maybeArrayAnnotation(annotation.typeAnnotation);\n      case 'TupleTypeAnnotation':\n      case 'ArrayTypeAnnotation':\n        return true;\n      case 'GenericTypeAnnotation':\n        return annotation.id.name === 'Array' ? true : null;\n      case 'UnionTypeAnnotation':\n        let falseCount = 0;\n        for (let type of annotation.types) {\n          const result = maybeArrayAnnotation(type);\n          if (result === true) {\n            return true;\n          }\n          else if (result === false) {\n            falseCount++;\n          }\n        }\n        if (falseCount === annotation.types.length) {\n          return false;\n        }\n        else {\n          return null;\n        }\n      case 'AnyTypeAnnotation':\n      case 'MixedTypeAnnotation':\n      case 'IntersectionTypeAnnotation':\n        return null;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Returns `true` if the annotation is compatible with an iterable,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */\n  function maybeIterableAnnotation (annotation: TypeAnnotation): ?boolean {\n    switch (annotation.type) {\n      case 'TypeAnnotation':\n      case 'FunctionTypeParam':\n      case 'NullableTypeAnnotation':\n        return maybeIterableAnnotation(annotation.typeAnnotation);\n      case 'TupleTypeAnnotation':\n      case 'ArrayTypeAnnotation':\n        return true;\n      case 'GenericTypeAnnotation':\n        return annotation.id.name === 'Iterable' ? true : null;\n      case 'UnionTypeAnnotation':\n        let falseCount = 0;\n        for (let type of annotation.types) {\n          const result = maybeIterableAnnotation(type);\n          if (result === true) {\n            return true;\n          }\n          else if (result === false) {\n            falseCount++;\n          }\n        }\n        if (falseCount === annotation.types.length) {\n          return false;\n        }\n        else {\n          return null;\n        }\n      case 'BooleanTypeAnnotation':\n      case 'BooleanLiteralTypeAnnotation':\n      case 'NumericLiteralTypeAnnotation':\n      case 'NumberTypeAnnotation':\n      case 'VoidTypeAnnotation':\n      case 'NullLiteralTypeAnnotation':\n        return false;\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * Returns `true` if the annotation is compatible with a tuple,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */\n  function maybeTupleAnnotation (annotation: TypeAnnotation): ?boolean {\n    switch (annotation.type) {\n      case 'TypeAnnotation':\n      case 'FunctionTypeParam':\n      case 'NullableTypeAnnotation':\n        return maybeTupleAnnotation(annotation.typeAnnotation);\n      case 'TupleTypeAnnotation':\n        return true;\n      case 'UnionTypeAnnotation':\n        let falseCount = 0;\n        for (let type of annotation.types) {\n          const result = maybeTupleAnnotation(type);\n          if (result === true) {\n            return true;\n          }\n          else if (result === false) {\n            falseCount++;\n          }\n        }\n        if (falseCount === annotation.types.length) {\n          return false;\n        }\n        else {\n          return null;\n        }\n      case 'GenericTypeAnnotation':\n      case 'AnyTypeAnnotation':\n      case 'ArrayTypeAnnotation':\n      case 'MixedTypeAnnotation':\n      case 'IntersectionTypeAnnotation':\n        return null;\n      default:\n        return false;\n    }\n  }\n\n  function humanReadableType (annotation: Node|TypeAnnotation): string {\n    switch (annotation.type) {\n      case 'TypeAnnotation':\n      case 'FunctionTypeParam':\n        return humanReadableType(annotation.typeAnnotation);\n\n      case 'FunctionTypeAnnotation':\n        // @fixme babel doesn't seem to like generating FunctionTypeAnnotations yet\n        return `(${annotation.params.map(humanReadableType).join(', ')}) => ${humanReadableType(annotation.returnType)}`;\n      case 'GenericTypeAnnotation':\n        const path = getNodePath(annotation);\n        const checker = path && getTypeChecker(annotation.id, path.scope);\n        if (checker && checker.node.savedTypeAnnotation) {\n          return humanReadableType(checker.node.savedTypeAnnotation);\n        }\n        else {\n          return generate(annotation).code;\n        }\n      default:\n        return generate(annotation).code;\n    }\n  }\n\n  /**\n   * Get the path directly from a node.\n   */\n  function getNodePath (node: Node): ?NodePath {\n    if (node._paths && node._paths.length) {\n      return node._paths[0];\n    }\n    else {\n      return null;\n    }\n  }\n\n  function getTypeChecker (id: Identifier|QualifiedTypeIdentifier, scope: Scope): NodePath|false {\n    const binding = scope.getBinding(id.name);\n    if (binding === undefined) {\n      return false;\n    }\n    const {path} = binding;\n    if (path == null) {\n      return false;\n    }\n    else if (path.type === 'TypeAlias') {\n      return path;\n    }\n    else if (path.type === 'VariableDeclaration' && path.node.isTypeChecker) {\n      return path.get('declarations')[0];\n    }\n    else if (path.isImportSpecifier() && path.parent.importKind === 'type') {\n      return path;\n    }\n    return false;\n  }\n\n  function isTypeChecker (id: Identifier|QualifiedTypeIdentifier, scope: Scope): boolean {\n    const binding = scope.getBinding(id.name);\n    if (binding === undefined) {\n      return false;\n    }\n    const {path} = binding;\n    if (path == null) {\n      return false;\n    }\n    else if (path.type === 'TypeAlias' || (path.type === 'VariableDeclaration' && path.node.isTypeChecker)) {\n      return true;\n    }\n    else if (path.isImportSpecifier() && path.parent.importKind === 'type') {\n      return true;\n    }\n    return false;\n  }\n\n  function isPolymorphicType (id: Identifier|QualifiedTypeIdentifier, scope: Scope): boolean {\n    const binding = scope.getBinding(id.name);\n    if (binding !== undefined) {\n      return false;\n    }\n    let {path} = scope;\n    while (path && path.type !== 'Program') {\n      const {node} = path;\n      if ((t.isFunction(node) || t.isClass(node)) && node.typeParameters) {\n        for (let param of node.typeParameters.params) {\n          param.isPolymorphicType = true;\n          if (param.name === id.name) {\n            return true;\n          }\n        }\n      }\n      path = path.parentPath;\n    }\n    return false;\n  }\n\n  function getPolymorphicType (id: Identifier|QualifiedTypeIdentifier, scope: Scope): ?Node {\n    const binding = scope.getBinding(id.name);\n    if (binding !== undefined) {\n      return false;\n    }\n    let {path} = scope;\n    while (path && path.type !== 'Program') {\n      const {node} = path;\n      if (t.isFunction(node) && node.typeParameters) {\n        for (let param of node.typeParameters.params) {\n          param.isPolymorphicType = true;\n          if (param.name === id.name) {\n            return param;\n          }\n        }\n      }\n      path = path.parent;\n    }\n    return null;\n  }\n\n  function collectParamChecks (path: NodePath, context: VisitorContext): Node[] {\n    return path.get('params').map((param) => {\n      const {node} = param;\n      if (node.type === 'AssignmentPattern') {\n        if (node.left.typeAnnotation) {\n          return createDefaultParamGuard(param, context);\n        }\n      }\n      else if (node.type === 'RestElement') {\n        if (node.typeAnnotation) {\n          return createRestParamGuard(param, context);\n        }\n      }\n      else if (node.typeAnnotation) {\n        return createParamGuard(param, context);\n      }\n    }).filter(identity);\n  }\n\n  function createParamGuard (path: NodePath, context: VisitorContext): ?Node {\n    const {node, scope} = path;\n    node.hasBeenTypeChecked = true;\n    node.savedTypeAnnotation = node.typeAnnotation;\n    let checkable;\n    if (node.type === 'ObjectPattern') {\n      node.name = path.key;\n      checkable = t.memberExpression(t.identifier('arguments'), t.numericLiteral(path.key), true);\n    }\n    else {\n      checkable = node;\n    }\n    let check = checkAnnotation(checkable, node.typeAnnotation, scope);\n    if (!check) {\n      return;\n    }\n    if (node.optional) {\n      check = t.logicalExpression(\n        '||',\n        checks.undefined({input: checkable}),\n        check\n      );\n    }\n    const message = paramTypeErrorMessage(checkable, context, node.typeAnnotation);\n    return guard({\n      check,\n      message\n    });\n  }\n\n  function createDefaultParamGuard (path: NodePath, context: VisitorContext): ?Node {\n    const {node, scope} = path;\n    const {left: id, right: value} = node;\n    const ok = staticCheckAnnotation(path.get('right'), id.typeAnnotation);\n    if (ok === false) {\n      throw path.buildCodeFrameError(\n        buildErrorMessage(\n          `Invalid default value for argument \"${id.name}\".`,\n          id.typeAnnotation,\n          getAnnotation(path.get('right'))\n        )\n      );\n    }\n    return createParamGuard(path.get('left'), context);\n  }\n\n  function createRestParamGuard (path: NodePath, context: VisitorContext): ?Node {\n    const {node, scope} = path;\n    const {argument: id} = node;\n    id.hasBeenTypeChecked = true;\n    node.savedTypeAnnotation = node.typeAnnotation;\n    if (isStrictlyArrayAnnotation(node.typeAnnotation) === false) {\n      throw path.buildCodeFrameError(\n        buildErrorMessage(\n          `Invalid type annotation for rest argument \"${id.name}\".`,\n          t.genericTypeAnnotation(t.identifier('Array')),\n          node.typeAnnotation\n        )\n      );\n    }\n    let check = checkAnnotation(id, node.typeAnnotation, scope);\n    if (!check) {\n      return;\n    }\n    if (node.optional) {\n      check = t.logicalExpression(\n        '||',\n        checks.undefined({input: id}),\n        check\n      );\n    }\n    const message = paramTypeErrorMessage(id, context, node.typeAnnotation);\n    return guard({\n      check,\n      message\n    });\n  }\n\n  function returnTypeErrorMessage (path: NodePath, fn: Node, id: ?Identifier|Literal, context: VisitorContext): Node {\n    const {node, scope} = path;\n    const name = fn.id ? fn.id.name : '';\n    let annotation = fn.returnType;\n    if (annotation.type === 'TypeAnnotation') {\n      annotation = annotation.typeAnnotation;\n    }\n    if (fn.generator && isGeneratorAnnotation(annotation) && annotation.typeParameters && annotation.typeParameters.params.length > 1) {\n      annotation = annotation.typeParameters.params[1];\n    }\n    const message = `Function ${name ? `\"${name}\" ` : ''}return value violates contract.\\n\\nExpected:\\n${humanReadableType(annotation)}\\n\\nGot:\\n`;\n\n    return t.binaryExpression(\n      '+',\n      t.stringLiteral(message),\n      id ? readableName({inspect: context.inspect, input: id}) : node.argument ? readableName({inspect: context.inspect, input: node.argument}) : t.stringLiteral('undefined')\n    );\n  }\n\n  function yieldTypeErrorMessage (fn: Node, annotation: TypeAnnotation, id: Identifier|Literal, context: VisitorContext): Node {\n    const name = fn.id ? fn.id.name : '';\n    const message = `Function ${name ? `\"${name}\" ` : ''}yielded an invalid value.\\n\\nExpected:\\n${humanReadableType(annotation)}\\n\\nGot:\\n`;\n\n    return t.binaryExpression(\n      '+',\n      t.stringLiteral(message),\n      readableName({inspect: context.inspect, input: id})\n    );\n  }\n  function yieldNextTypeErrorMessage (fn: Node, annotation: TypeAnnotation, id: Identifier|Literal, context: VisitorContext): Node {\n    const name = fn.id ? fn.id.name : '';\n    const message = `Generator ${name ? `\"${name}\" ` : ''}received an invalid next value.\\n\\nExpected:\\n${humanReadableType(annotation)}\\n\\nGot:\\n`;\n\n    return t.binaryExpression(\n      '+',\n      t.stringLiteral(message),\n      readableName({inspect: context.inspect, input: id})\n    );\n  }\n\n  function paramTypeErrorMessage (node: Node, context: VisitorContext, typeAnnotation: TypeAnnotation = node.typeAnnotation): Node {\n    let name = node.name;\n    if (node.type === 'MemberExpression' && node.object.name === 'arguments') {\n      name = node.property.value;\n    }\n    const message = `Value of ${node.optional ? 'optional ' : ''}argument ${JSON.stringify(name)} violates contract.\\n\\nExpected:\\n${humanReadableType(typeAnnotation)}\\n\\nGot:\\n`;\n\n    return t.binaryExpression(\n      '+',\n      t.stringLiteral(message),\n      readableName({inspect: context.inspect, input: node})\n    );\n  }\n\n  function varTypeErrorMessage (node: Node, context: VisitorContext): Node {\n    const annotation: TypeAnnotation = node.typeAnnotation;\n    if (node.type === 'Identifier') {\n      const name = node.name;\n      const message = `Value of variable \"${name}\" violates contract.\\n\\nExpected:\\n${humanReadableType(annotation)}\\n\\nGot:\\n`;\n      return t.binaryExpression(\n        '+',\n        t.stringLiteral(message),\n        readableName({inspect: context.inspect, input: node})\n      );\n    }\n    else {\n      const message = `Value of \"${humanReadableType(node)}\" violates contract.\\n\\nExpected:\\n${humanReadableType(annotation)}\\n\\nGot:\\n`;\n      return t.binaryExpression(\n        '+',\n        t.stringLiteral(message),\n        readableName({inspect: context.inspect, input: node})\n      );\n    }\n  }\n\n  /**\n   * Create a React property validator\n   */\n  function generatePropType (annotation: TypeAnnotation, scope: Scope, context: VisitorContext) {\n    const prop = t.identifier('prop');\n    const check = checkAnnotation(prop, annotation, scope);\n    if (check) {\n      return propType({\n        check,\n        prop,\n        expected: t.stringLiteral(humanReadableType(annotation)),\n        got: readableName({inspect: context.inspect, input: prop})\n      });\n    } else {\n      return t.functionExpression(null, [], t.blockStatement([]));\n    }\n  }\n  \n  /**\n   * Determine whether the given node can produce purely boolean results.\n   */\n  function isBooleanExpression (node: Node) {\n    if (node.type === 'BinaryExpression' && BOOLEAN_BINARY_OPERATORS.indexOf(node.operator) > -1) {\n      return true;\n    }\n    else if (node.type === 'LogicalExpression') {\n      return isBooleanExpression(node.left) && isBooleanExpression(node.right);\n    }\n    else {\n      return false;\n    }\n  }\n\n  /**\n   * Convert type specifier to expression.\n   */\n  function createTypeExpression (node: Node) : Object {\n    if (node.type == 'Identifier') {\n      return node;\n    }\n    else if (node.type == 'QualifiedTypeIdentifier') {\n      return t.memberExpression(\n        createTypeExpression(node.qualification),\n        createTypeExpression(node.id)\n      );\n    }\n\n    throw this.errorWithNode(`Unsupported type: ${node.type}`);\n  }\n\n  /**\n   * Get name of a type as a string.\n   */\n  function getTypeName (node: Node): string {\n    if(node.type == 'Identifier') {\n      return node.name\n    }\n    else if(node.type == 'QualifiedTypeIdentifier') {\n      return getTypeName(node.qualification) + '.' + getTypeName(node.id);\n    }\n\n    throw this.errorWithNode(`Unsupported type: ${node.type}`);\n  }\n\n\n  /**\n   * Union two arrays.\n   */\n  function union (arr1: Array, arr2: Array): Array {\n    for (let i = 0; i < arr2.length; i++) {\n      let item = arr2[i];\n      if (arr1.indexOf(item) === -1) {\n        arr1.push(item);\n      }\n    }\n    return arr1;\n  }\n\n\n  /**\n   * Determine whether the given annotation allows any value.\n   */\n  function allowsAny (annotation: TypeAnnotation): boolean {\n    if (annotation.type === 'TypeAnnotation' || annotation.type === 'NullableTypeAnnotation') {\n      return allowsAny(annotation.typeAnnotation);\n    }\n    else if (annotation.type === 'AnyTypeAnnotation' || annotation.type === 'MixedTypeAnnotation') {\n      return true;\n    }\n    else if (annotation.type === 'UnionTypeAnnotation') {\n      return annotation.types.some(allowsAny);\n    }\n    else {\n      return false;\n    }\n  }\n\n  /**\n   * Determine whether a given node is nully (null or undefined).\n   */\n  function isNodeNully (node: ?Node): boolean {\n    if (node == null) {\n      return true;\n    }\n    else if (node.type === 'Identifier' && node.name === 'undefined') {\n      return true;\n    }\n    else if (node.type === 'Literal' && node.value === null) {\n      return true;\n    }\n    else if (node.type === 'UnaryExpression' && node.operator === 'void') {\n      return true;\n    }\n    else {\n      return false;\n    }\n  }\n\n  /**\n   * Determine whether the file should be checked\n   */\n  function mustCheckFile(path: NodePath, opts): boolean {\n    if (path.node.leadingComments && path.node.leadingComments.length) {\n      return opts.only && !skipEnvironment(path.node.leadingComments, opts);\n    }\n    return false;\n  }\n  /**\n   * Determine whether the file should be skipped, based on the comments attached to the given node.\n   */\n  function maybeSkipFile (path: NodePath, opts): boolean {\n    if (path.node.leadingComments && path.node.leadingComments.length) {\n      if (skipEnvironment(path.node.leadingComments, opts)) {\n        return true;\n      }\n      return path.node.leadingComments.some(comment => PRAGMA_IGNORE_FILE.test(comment.value));\n    }\n    return false;\n  }\n\n  /**\n   * Maybe skip the given path if it has a relevant pragma.\n   */\n  function maybeSkip (path: NodePath): boolean {\n    const {node} = path;\n    if (node.hasBeenTypeChecked) {\n      return true;\n    }\n    if (node.leadingComments && node.leadingComments.length) {\n      const comment = node.leadingComments[node.leadingComments.length - 1];\n      if (PRAGMA_IGNORE_STATEMENT.test(comment.value)) {\n        path.skip();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * A function that returns its first argument, useful when filtering.\n   */\n  function identity <T> (input: T): T {\n    return input;\n  }\n\n  function getExpression (node: Node): Node {\n    return t.isExpressionStatement(node) ? node.expression : node;\n  }\n\n  function expression (input: string): Function {\n    const fn: Function = template(input);\n    return function (...args) {\n      const node: Node = fn(...args);\n      return getExpression(node);\n    };\n  }\n}\n"]}